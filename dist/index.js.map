{"version":3,"sources":["../lib/services/LokaliseDownload.ts","../lib/errors/LokaliseError.ts","../lib/services/LokaliseFileExchange.ts","../lib/services/LokaliseUpload.ts"],"sourcesContent":["import fs from \"node:fs\";\nimport os from \"node:os\";\nimport path from \"node:path\";\nimport { pipeline } from \"node:stream\";\nimport { promisify } from \"node:util\";\nimport type {\n\tDownloadBundle,\n\tDownloadFileParams,\n\tDownloadedFileProcessDetails,\n\tQueuedProcess,\n} from \"@lokalise/node-api\";\nimport yauzl from \"yauzl\";\nimport { LokaliseError } from \"../errors/LokaliseError.js\";\nimport type { DownloadTranslationParams } from \"../interfaces/index.js\";\nimport { LokaliseFileExchange } from \"./LokaliseFileExchange.js\";\n\n/**\n * Handles downloading and extracting translation files from Lokalise.\n */\nexport class LokaliseDownload extends LokaliseFileExchange {\n\tprivate readonly streamPipeline = promisify(pipeline);\n\tprivate static readonly defaultProcessParams = {\n\t\tasyncDownload: false,\n\t\tpollInitialWaitTime: 1000,\n\t\tpollMaximumWaitTime: 120_000,\n\t\tbundleDownloadTimeout: 0,\n\t};\n\n\t/**\n\t * Downloads translations from Lokalise, optionally using async polling, and extracts them to disk.\n\t *\n\t * @param downloadTranslationParams - Full configuration for the download process, extraction destination, and optional polling or timeout settings.\n\t * @throws {LokaliseError} If the download, polling, or extraction fails.\n\t */\n\tasync downloadTranslations({\n\t\tdownloadFileParams,\n\t\textractParams = {},\n\t\tprocessDownloadFileParams,\n\t}: DownloadTranslationParams): Promise<void> {\n\t\tconst {\n\t\t\tasyncDownload,\n\t\t\tpollInitialWaitTime,\n\t\t\tpollMaximumWaitTime,\n\t\t\tbundleDownloadTimeout,\n\t\t} = {\n\t\t\t...LokaliseDownload.defaultProcessParams,\n\t\t\t...processDownloadFileParams,\n\t\t};\n\n\t\tlet translationsBundleURL: string;\n\n\t\tif (asyncDownload) {\n\t\t\tconst downloadProcess =\n\t\t\t\tawait this.getTranslationsBundleAsync(downloadFileParams);\n\n\t\t\tconst completedProcess = (\n\t\t\t\tawait this.pollProcesses(\n\t\t\t\t\t[downloadProcess],\n\t\t\t\t\tpollInitialWaitTime,\n\t\t\t\t\tpollMaximumWaitTime,\n\t\t\t\t)\n\t\t\t)[0];\n\n\t\t\tif (completedProcess.status === \"finished\") {\n\t\t\t\tconst completedProcessDetails =\n\t\t\t\t\tcompletedProcess.details as DownloadedFileProcessDetails;\n\t\t\t\ttranslationsBundleURL = completedProcessDetails.download_url;\n\t\t\t} else {\n\t\t\t\tthrow new LokaliseError(\n\t\t\t\t\t`Download process took too long to finalize; gave up after ${pollMaximumWaitTime}ms`,\n\t\t\t\t\t500,\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tconst translationsBundle =\n\t\t\t\tawait this.getTranslationsBundle(downloadFileParams);\n\t\t\ttranslationsBundleURL = translationsBundle.bundle_url;\n\t\t}\n\n\t\tconst zipFilePath = await this.downloadZip(\n\t\t\ttranslationsBundleURL,\n\t\t\tbundleDownloadTimeout,\n\t\t);\n\n\t\ttry {\n\t\t\tawait this.unpackZip(\n\t\t\t\tzipFilePath,\n\t\t\t\tpath.resolve(extractParams.outputDir ?? \"./\"),\n\t\t\t);\n\t\t} finally {\n\t\t\tawait fs.promises.unlink(zipFilePath);\n\t\t}\n\t}\n\n\t/**\n\t * Unpacks a ZIP file into the specified directory.\n\t *\n\t * @param zipFilePath - Path to the ZIP file.\n\t * @param outputDir - Directory to extract the files into.\n\t * @throws {LokaliseError} If extraction fails or malicious paths are detected.\n\t */\n\tprotected async unpackZip(\n\t\tzipFilePath: string,\n\t\toutputDir: string,\n\t): Promise<void> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tyauzl.open(zipFilePath, { lazyEntries: true }, (err, zipfile) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn reject(\n\t\t\t\t\t\tnew LokaliseError(\n\t\t\t\t\t\t\t`Failed to open ZIP file at ${zipFilePath}: ${err.message}`,\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (!zipfile) {\n\t\t\t\t\treturn reject(\n\t\t\t\t\t\tnew LokaliseError(`ZIP file is invalid or empty: ${zipFilePath}`),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tzipfile.readEntry();\n\n\t\t\t\tzipfile.on(\"entry\", (entry) => {\n\t\t\t\t\tthis.handleZipEntry(entry, zipfile, outputDir)\n\t\t\t\t\t\t.then(() => zipfile.readEntry())\n\t\t\t\t\t\t.catch(reject);\n\t\t\t\t});\n\n\t\t\t\tzipfile.on(\"end\", resolve);\n\t\t\t\tzipfile.on(\"error\", reject);\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate async handleZipEntry(\n\t\tentry: yauzl.Entry,\n\t\tzipfile: yauzl.ZipFile,\n\t\toutputDir: string,\n\t): Promise<void> {\n\t\tconst fullPath = this.processZipEntryPath(outputDir, entry.fileName);\n\n\t\tif (entry.fileName.endsWith(\"/\")) {\n\t\t\t// it's a directory\n\t\t\tawait this.createDir(fullPath);\n\t\t\treturn;\n\t\t}\n\n\t\tawait this.createDir(path.dirname(fullPath));\n\n\t\treturn new Promise((response, reject) => {\n\t\t\tzipfile.openReadStream(entry, (readErr, readStream) => {\n\t\t\t\tif (readErr || !readStream) {\n\t\t\t\t\treturn reject(\n\t\t\t\t\t\tnew LokaliseError(`Failed to read ZIP entry: ${entry.fileName}`),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst writeStream = fs.createWriteStream(fullPath);\n\t\t\t\treadStream.pipe(writeStream);\n\t\t\t\twriteStream.on(\"finish\", response);\n\t\t\t\twriteStream.on(\"error\", reject);\n\t\t\t\treadStream.on(\"error\", reject);\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Downloads a ZIP file from the given URL.\n\t *\n\t * @param url - The URL of the ZIP file.\n\t * @returns The file path of the downloaded ZIP file.\n\t * @throws {LokaliseError} If the download fails or the response body is empty.\n\t */\n\tprotected async downloadZip(\n\t\turl: string,\n\t\tdownloadTimeout = 0,\n\t): Promise<string> {\n\t\tconst bundleURL = this.assertHttpUrl(url);\n\n\t\tconst uid = `${process.pid}-${Date.now()}-${Math.random().toString(16).slice(2)}`;\n\t\tconst tempZipPath = path.join(os.tmpdir(), `lokalise-${uid}.zip`);\n\t\tlet response: Response;\n\n\t\tconst signal =\n\t\t\tdownloadTimeout > 0 ? AbortSignal.timeout(downloadTimeout) : undefined;\n\n\t\ttry {\n\t\t\tresponse = await fetch(bundleURL, {\n\t\t\t\tsignal,\n\t\t\t});\n\t\t} catch (err) {\n\t\t\tif (err instanceof Error) {\n\t\t\t\tif (err.name === \"TimeoutError\") {\n\t\t\t\t\tthrow new LokaliseError(\n\t\t\t\t\t\t`Request timed out after ${downloadTimeout}ms`,\n\t\t\t\t\t\t408,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treason: \"timeout\",\n\t\t\t\t\t\t},\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tthrow new LokaliseError(err.message, 500, {\n\t\t\t\t\treason: \"network or fetch error\",\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthrow new LokaliseError(\"An unknown error occurred\", 500, {\n\t\t\t\treason: String(err),\n\t\t\t});\n\t\t}\n\n\t\tif (!response.ok) {\n\t\t\tthrow new LokaliseError(\n\t\t\t\t`Failed to download ZIP file: ${response.statusText} (${response.status})`,\n\t\t\t);\n\t\t}\n\n\t\tconst body = response.body;\n\t\tif (!body) {\n\t\t\tthrow new LokaliseError(\n\t\t\t\t`Response body is null. Cannot download ZIP file from URL: ${url}`,\n\t\t\t);\n\t\t}\n\n\t\tawait this.streamPipeline(body, fs.createWriteStream(tempZipPath));\n\t\treturn tempZipPath;\n\t}\n\n\t/**\n\t * Retrieves a translation bundle from Lokalise with retries and exponential backoff.\n\t *\n\t * @param downloadFileParams - Parameters for Lokalise API file download.\n\t * @returns The downloaded bundle metadata.\n\t * @throws {LokaliseError} If retries are exhausted or an API error occurs.\n\t */\n\tprotected async getTranslationsBundle(\n\t\tdownloadFileParams: DownloadFileParams,\n\t): Promise<DownloadBundle> {\n\t\treturn this.withExponentialBackoff(() =>\n\t\t\tthis.apiClient.files().download(this.projectId, downloadFileParams),\n\t\t);\n\t}\n\n\t/**\n\t * Retrieves a translation bundle from Lokalise with retries and exponential backoff.\n\t *\n\t * @param downloadFileParams - Parameters for Lokalise API file download.\n\t * @returns The queued process.\n\t * @throws {LokaliseError} If retries are exhausted or an API error occurs.\n\t */\n\tprotected async getTranslationsBundleAsync(\n\t\tdownloadFileParams: DownloadFileParams,\n\t): Promise<QueuedProcess> {\n\t\treturn this.withExponentialBackoff(() =>\n\t\t\tthis.apiClient.files().async_download(this.projectId, downloadFileParams),\n\t\t);\n\t}\n\n\tprivate async createDir(dir: string): Promise<void> {\n\t\tawait fs.promises.mkdir(dir, { recursive: true });\n\t}\n\n\tprivate processZipEntryPath(\n\t\toutputDir: string,\n\t\tentryFilename: string,\n\t): string {\n\t\t// Validate paths to avoid path traversal issues\n\t\tconst fullPath = path.resolve(outputDir, entryFilename);\n\t\tconst relative = path.relative(outputDir, fullPath);\n\t\tif (relative.startsWith(\"..\") || path.isAbsolute(relative)) {\n\t\t\tthrow new LokaliseError(`Malicious ZIP entry detected: ${entryFilename}`);\n\t\t}\n\n\t\treturn fullPath;\n\t}\n\n\tprivate assertHttpUrl(value: string): URL {\n\t\tlet parsed: URL;\n\t\ttry {\n\t\t\tparsed = new URL(value);\n\t\t} catch {\n\t\t\tthrow new LokaliseError(`Invalid URL: ${value}`);\n\t\t}\n\n\t\tif (parsed.protocol !== \"http:\" && parsed.protocol !== \"https:\") {\n\t\t\tthrow new LokaliseError(`Unsupported protocol in URL: ${value}`);\n\t\t}\n\n\t\treturn parsed;\n\t}\n}\n","import type { LokaliseError as ILokaliseError } from \"../interfaces/LokaliseError.js\";\n\n/**\n * Represents a custom error.\n */\nexport class LokaliseError extends Error implements ILokaliseError {\n\t/**\n\t * The error code representing the type of Lokalise API error.\n\t */\n\tcode?: number;\n\n\t/**\n\t * Additional details about the error.\n\t */\n\tdetails?: Record<string, string | number | boolean>;\n\n\t/**\n\t * Creates a new instance of LokaliseError.\n\t *\n\t * @param message - The error message.\n\t * @param code - The error code (optional).\n\t * @param details - Optional additional details about the error.\n\t */\n\tconstructor(\n\t\tmessage: string,\n\t\tcode?: number,\n\t\tdetails?: Record<string, string | number | boolean>,\n\t) {\n\t\tsuper(message);\n\t\tthis.code = code;\n\t\tthis.details = details;\n\t}\n\n\t/**\n\t * Returns a string representation of the error, including code and details.\n\t *\n\t * @returns The formatted error message.\n\t */\n\toverride toString(): string {\n\t\tlet baseMessage = `LokaliseError: ${this.message}`;\n\t\tif (this.code) {\n\t\t\tbaseMessage += ` (Code: ${this.code})`;\n\t\t}\n\t\tif (this.details) {\n\t\t\tconst formattedDetails = Object.entries(this.details)\n\t\t\t\t.map(([key, value]) => `${key}: ${value}`)\n\t\t\t\t.join(\", \");\n\n\t\t\tbaseMessage += ` | Details: ${formattedDetails}`;\n\t\t}\n\t\treturn baseMessage;\n\t}\n}\n","import {\n\tLokaliseApi,\n\tApiError as LokaliseApiError,\n\tLokaliseApiOAuth,\n} from \"@lokalise/node-api\";\nimport type { ClientParams, QueuedProcess } from \"@lokalise/node-api\";\nimport { LokaliseError } from \"../errors/LokaliseError.js\";\nimport type {\n\tLokaliseExchangeConfig,\n\tRetryParams,\n} from \"../interfaces/index.js\";\n\n/**\n * A utility class for exchanging files with the Lokalise API.\n */\nexport class LokaliseFileExchange {\n\t/**\n\t * The Lokalise API client instance.\n\t */\n\tpublic readonly apiClient: LokaliseApi;\n\n\t/**\n\t * The ID of the project in Lokalise.\n\t */\n\tprotected readonly projectId: string;\n\n\t/**\n\t * Retry parameters for API requests.\n\t */\n\tprotected readonly retryParams: RetryParams;\n\n\t/**\n\t * Default retry parameters for API requests.\n\t */\n\tprivate static readonly defaultRetryParams: RetryParams = {\n\t\tmaxRetries: 3,\n\t\tinitialSleepTime: 1000,\n\t};\n\n\tprivate static readonly PENDING_STATUSES = [\n\t\t\"queued\",\n\t\t\"pre_processing\",\n\t\t\"running\",\n\t\t\"post_processing\",\n\t];\n\tprivate static readonly FINISHED_STATUSES = [\n\t\t\"finished\",\n\t\t\"cancelled\",\n\t\t\"failed\",\n\t];\n\n\tprivate static readonly RETRYABLE_CODES = [408, 429];\n\n\t/**\n\t * Creates a new instance of LokaliseFileExchange.\n\t *\n\t * @param clientConfig - Configuration for the Lokalise SDK.\n\t * @param exchangeConfig - The configuration object for file exchange operations.\n\t * @throws {LokaliseError} If the provided configuration is invalid.\n\t */\n\tconstructor(\n\t\tclientConfig: ClientParams,\n\t\t{ projectId, useOAuth2 = false, retryParams }: LokaliseExchangeConfig,\n\t) {\n\t\tif (!clientConfig.apiKey || typeof clientConfig.apiKey !== \"string\") {\n\t\t\tthrow new LokaliseError(\"Invalid or missing API token.\");\n\t\t}\n\t\tif (useOAuth2) {\n\t\t\tthis.apiClient = new LokaliseApiOAuth(clientConfig);\n\t\t} else {\n\t\t\tthis.apiClient = new LokaliseApi(clientConfig);\n\t\t}\n\n\t\tif (!projectId || typeof projectId !== \"string\") {\n\t\t\tthrow new LokaliseError(\"Invalid or missing Project ID.\");\n\t\t}\n\t\tthis.projectId = projectId;\n\n\t\tthis.retryParams = {\n\t\t\t...LokaliseFileExchange.defaultRetryParams,\n\t\t\t...retryParams,\n\t\t};\n\n\t\tif (this.retryParams.maxRetries < 0) {\n\t\t\tthrow new LokaliseError(\n\t\t\t\t\"maxRetries must be greater than or equal to zero.\",\n\t\t\t);\n\t\t}\n\t\tif (this.retryParams.initialSleepTime <= 0) {\n\t\t\tthrow new LokaliseError(\"initialSleepTime must be a positive value.\");\n\t\t}\n\t}\n\n\t/**\n\t * Executes an asynchronous operation with exponential backoff retry logic.\n\t *\n\t * Retries the provided operation in the event of specific retryable errors (e.g., 429 Too Many Requests,\n\t * 408 Request Timeout) using an exponential backoff strategy with optional jitter. If the maximum number\n\t * of retries is exceeded, it throws an error. Non-retryable errors are immediately propagated.\n\t *\n\t * @template T The type of the value returned by the operation.\n\t * @param operation - The asynchronous operation to execute.\n\t * @returns A promise that resolves to the result of the operation if successful.\n\t * @throws {LokaliseError} If the maximum number of retries is reached or a non-retryable error occurs.\n\t */\n\tprotected async withExponentialBackoff<T>(\n\t\toperation: () => Promise<T>,\n\t): Promise<T> {\n\t\tconst { maxRetries, initialSleepTime } = this.retryParams;\n\n\t\tfor (let attempt = 1; attempt <= maxRetries + 1; attempt++) {\n\t\t\ttry {\n\t\t\t\treturn await operation();\n\t\t\t} catch (error: unknown) {\n\t\t\t\tif (\n\t\t\t\t\terror instanceof LokaliseApiError &&\n\t\t\t\t\tLokaliseFileExchange.RETRYABLE_CODES.includes(error.code)\n\t\t\t\t) {\n\t\t\t\t\tif (attempt === maxRetries + 1) {\n\t\t\t\t\t\tthrow new LokaliseError(\n\t\t\t\t\t\t\t`Maximum retries reached: ${error.message ?? \"Unknown error\"}`,\n\t\t\t\t\t\t\terror.code,\n\t\t\t\t\t\t\terror.details,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tawait LokaliseFileExchange.sleep(\n\t\t\t\t\t\tinitialSleepTime * 2 ** (attempt - 1),\n\t\t\t\t\t);\n\t\t\t\t} else if (error instanceof LokaliseApiError) {\n\t\t\t\t\tthrow new LokaliseError(error.message, error.code, error.details);\n\t\t\t\t} else {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// This line is unreachable but keeps TS happy.\n\t\t// istanbul ignore next\n\t\tthrow new LokaliseError(\"Unexpected error during operation.\", 500);\n\t}\n\n\t/**\n\t * Polls the status of queued processes until they are marked as \"finished\" or until the maximum wait time is exceeded.\n\t *\n\t * @param {QueuedProcess[]} processes - The array of processes to poll.\n\t * @param {number} initialWaitTime - The initial wait time before polling in milliseconds.\n\t * @param {number} maxWaitTime - The maximum time to wait for processes in milliseconds.\n\t * @returns {Promise<QueuedProcess[]>} A promise resolving to the updated array of processes with their final statuses.\n\t */\n\tprotected async pollProcesses(\n\t\tprocesses: QueuedProcess[],\n\t\tinitialWaitTime: number,\n\t\tmaxWaitTime: number,\n\t): Promise<QueuedProcess[]> {\n\t\tconst startTime = Date.now();\n\t\tlet waitTime = initialWaitTime;\n\n\t\tconst processMap = new Map<string, QueuedProcess>();\n\n\t\t// Initialize processMap and set a default status if missing\n\t\tconst pendingProcessIds = new Set<string>();\n\n\t\tfor (const process of processes) {\n\t\t\tif (!process.status) {\n\t\t\t\tprocess.status = \"queued\"; // Assign default status if missing\n\t\t\t}\n\n\t\t\tprocessMap.set(process.process_id, process);\n\n\t\t\tif (LokaliseFileExchange.PENDING_STATUSES.includes(process.status)) {\n\t\t\t\tpendingProcessIds.add(process.process_id);\n\t\t\t}\n\t\t}\n\n\t\twhile (pendingProcessIds.size > 0 && Date.now() - startTime < maxWaitTime) {\n\t\t\tawait Promise.all(\n\t\t\t\t[...pendingProcessIds].map(async (processId) => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst updatedProcess = await this.getUpdatedProcess(processId);\n\n\t\t\t\t\t\tprocessMap.set(processId, updatedProcess);\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tLokaliseFileExchange.FINISHED_STATUSES.includes(\n\t\t\t\t\t\t\t\tupdatedProcess.status,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tpendingProcessIds.delete(processId);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (_error) {\n\t\t\t\t\t\t// console.warn(`Failed to fetch process ${processId}:`, error);\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\tif (\n\t\t\t\tpendingProcessIds.size === 0 ||\n\t\t\t\tDate.now() - startTime >= maxWaitTime\n\t\t\t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tawait LokaliseFileExchange.sleep(waitTime);\n\t\t\twaitTime = Math.min(waitTime * 2, maxWaitTime - (Date.now() - startTime));\n\t\t}\n\n\t\treturn Array.from(processMap.values());\n\t}\n\n\t/**\n\t * Pauses execution for the specified number of milliseconds.\n\t *\n\t * @param ms - The time to sleep in milliseconds.\n\t * @returns A promise that resolves after the specified time.\n\t */\n\tprotected static sleep(ms: number): Promise<void> {\n\t\treturn new Promise((resolve) => setTimeout(resolve, ms));\n\t}\n\n\tprivate async getUpdatedProcess(processId: string): Promise<QueuedProcess> {\n\t\tconst updatedProcess = await this.apiClient\n\t\t\t.queuedProcesses()\n\t\t\t.get(processId, { project_id: this.projectId });\n\n\t\tif (!updatedProcess.status) {\n\t\t\tupdatedProcess.status = \"queued\"; // Ensure missing status is defaulted\n\t\t}\n\n\t\treturn updatedProcess;\n\t}\n}\n","import fs from \"node:fs\";\nimport path from \"node:path\";\nimport type { QueuedProcess, UploadFileParams } from \"@lokalise/node-api\";\nimport type {\n\tCollectFileParams,\n\tFileUploadError,\n\tPartialUploadFileParams,\n\tProcessUploadFileParams,\n\tProcessedFile,\n\tQueuedUploadProcessesWithErrors,\n\tUploadTranslationParams,\n} from \"../interfaces/index.js\";\nimport { LokaliseFileExchange } from \"./LokaliseFileExchange.js\";\n\n/**\n * Handles uploading translation files to Lokalise.\n */\nexport class LokaliseUpload extends LokaliseFileExchange {\n\tprivate readonly maxConcurrentProcesses = 6;\n\n\tprivate static readonly defaultPollingParams = {\n\t\tpollStatuses: false,\n\t\tpollInitialWaitTime: 1000,\n\t\tpollMaximumWaitTime: 120_000,\n\t};\n\n\t/**\n\t * Collects files, uploads them to Lokalise, and optionally polls for process completion, returning both processes and errors.\n\t *\n\t * @param {UploadTranslationParams} uploadTranslationParams - Parameters for collecting and uploading files.\n\t * @returns {Promise<{ processes: QueuedProcess[]; errors: FileUploadError[] }>} A promise resolving with successful processes and upload errors.\n\t */\n\tasync uploadTranslations({\n\t\tuploadFileParams,\n\t\tcollectFileParams,\n\t\tprocessUploadFileParams,\n\t}: UploadTranslationParams = {}): Promise<QueuedUploadProcessesWithErrors> {\n\t\tconst { pollStatuses, pollInitialWaitTime, pollMaximumWaitTime } = {\n\t\t\t...LokaliseUpload.defaultPollingParams,\n\t\t\t...processUploadFileParams,\n\t\t};\n\n\t\tconst collectedFiles = await this.collectFiles(collectFileParams);\n\n\t\tconst { processes, errors } = await this.parallelUpload(\n\t\t\tcollectedFiles,\n\t\t\tuploadFileParams,\n\t\t\tprocessUploadFileParams,\n\t\t);\n\n\t\tlet completedProcesses = processes;\n\n\t\tif (pollStatuses) {\n\t\t\tcompletedProcesses = await this.pollProcesses(\n\t\t\t\tprocesses,\n\t\t\t\tpollInitialWaitTime,\n\t\t\t\tpollMaximumWaitTime,\n\t\t\t);\n\t\t}\n\n\t\treturn { processes: completedProcesses, errors };\n\t}\n\n\t/**\n\t * Collects files from the filesystem based on the given parameters.\n\t *\n\t * @param {CollectFileParams} collectFileParams - Parameters for file collection, including directories, extensions, and patterns.\n\t * @returns {Promise<string[]>} A promise resolving with the list of collected file paths.\n\t */\n\tprotected async collectFiles({\n\t\tinputDirs = [\"./locales\"],\n\t\textensions = [\".*\"],\n\t\texcludePatterns = [],\n\t\trecursive = true,\n\t\tfileNamePattern = \".*\",\n\t}: CollectFileParams = {}): Promise<string[]> {\n\t\tconst queue = this.makeQueue(inputDirs);\n\t\tconst normalizedExtensions = this.normalizeExtensions(extensions);\n\t\tconst fileNameRegex = this.makeFilenameRegexp(fileNamePattern);\n\t\tconst excludeRegexes = this.makeExcludeRegExes(excludePatterns);\n\n\t\tconst files = await this.processCollectionQueue(\n\t\t\tqueue,\n\t\t\tnormalizedExtensions,\n\t\t\tfileNameRegex,\n\t\t\texcludeRegexes,\n\t\t\trecursive,\n\t\t);\n\n\t\treturn files.sort();\n\t}\n\n\t/**\n\t * Uploads a single file to Lokalise.\n\t *\n\t * @param {UploadFileParams} uploadParams - Parameters for uploading the file.\n\t * @returns {Promise<QueuedProcess>} A promise resolving with the upload process details.\n\t */\n\tprotected async uploadSingleFile(\n\t\tuploadParams: UploadFileParams,\n\t): Promise<QueuedProcess> {\n\t\treturn this.withExponentialBackoff(() =>\n\t\t\tthis.apiClient.files().upload(this.projectId, uploadParams),\n\t\t);\n\t}\n\n\t/**\n\t * Processes a file to prepare it for upload, converting it to base64 and extracting its language code.\n\t *\n\t * @param {string} file - The absolute path to the file.\n\t * @param {string} projectRoot - The root directory of the project.\n\t * @param {ProcessUploadFileParams} [processParams] - Optional processing settings including inferers.\n\t * @returns {Promise<ProcessedFile>} A promise resolving with the processed file details, including base64 content, relative path, and language code.\n\t */\n\tprotected async processFile(\n\t\tfile: string,\n\t\tprojectRoot: string,\n\t\tprocessParams?: ProcessUploadFileParams,\n\t): Promise<ProcessedFile> {\n\t\tlet relativePath: string;\n\t\ttry {\n\t\t\trelativePath = processParams?.filenameInferer\n\t\t\t\t? await processParams.filenameInferer(file)\n\t\t\t\t: \"\";\n\t\t\tif (!relativePath.trim()) {\n\t\t\t\tthrow new Error(\"Invalid filename: empty or only whitespace\");\n\t\t\t}\n\t\t} catch {\n\t\t\tconst toPosixPath = (p: string) => p.split(path.sep).join(path.posix.sep);\n\t\t\trelativePath = path.posix.relative(\n\t\t\t\ttoPosixPath(projectRoot),\n\t\t\t\ttoPosixPath(file),\n\t\t\t);\n\t\t}\n\n\t\tlet languageCode: string;\n\t\ttry {\n\t\t\tlanguageCode = processParams?.languageInferer\n\t\t\t\t? await processParams.languageInferer(file)\n\t\t\t\t: \"\";\n\t\t\tif (!languageCode.trim()) {\n\t\t\t\tthrow new Error(\"Invalid language code: empty or only whitespace\");\n\t\t\t}\n\t\t} catch {\n\t\t\tconst baseName = path.basename(relativePath);\n\t\t\tlanguageCode = baseName.split(\".\").slice(-2, -1)[0] ?? \"unknown\";\n\t\t}\n\n\t\tconst fileContent = await fs.promises.readFile(file);\n\n\t\treturn {\n\t\t\tdata: fileContent.toString(\"base64\"),\n\t\t\tfilename: relativePath,\n\t\t\tlang_iso: languageCode,\n\t\t};\n\t}\n\n\t/**\n\t * Uploads files in parallel with a limit on the number of concurrent uploads.\n\t *\n\t * @param {string[]} files - List of file paths to upload.\n\t * @param {Partial<UploadFileParams>} baseUploadFileParams - Base parameters for uploads.\n\t * @param {ProcessUploadFileParams} [processParams] - Optional processing settings including inferers.\n\t * @returns {Promise<{ processes: QueuedProcess[]; errors: FileUploadError[] }>} A promise resolving with successful processes and upload errors.\n\t */\n\tprivate async parallelUpload(\n\t\tfiles: string[],\n\t\tbaseUploadFileParams: PartialUploadFileParams = {},\n\t\tprocessParams?: ProcessUploadFileParams,\n\t): Promise<QueuedUploadProcessesWithErrors> {\n\t\tconst projectRoot = process.cwd();\n\t\tconst queuedProcesses: QueuedProcess[] = [];\n\t\tconst errors: FileUploadError[] = [];\n\t\tconst fileQueue = [...files];\n\n\t\tconst pool = new Array(this.maxConcurrentProcesses).fill(null).map(() =>\n\t\t\t(async () => {\n\t\t\t\twhile (fileQueue.length > 0) {\n\t\t\t\t\tconst file = fileQueue.shift();\n\t\t\t\t\tif (!file) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst processedFileParams = await this.processFile(\n\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\tprojectRoot,\n\t\t\t\t\t\t\tprocessParams,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst queuedProcess = await this.uploadSingleFile({\n\t\t\t\t\t\t\t...baseUploadFileParams,\n\t\t\t\t\t\t\t...processedFileParams,\n\t\t\t\t\t\t});\n\t\t\t\t\t\tqueuedProcesses.push(queuedProcess);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\terrors.push({ file, error });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})(),\n\t\t);\n\n\t\tawait Promise.all(pool);\n\t\treturn { processes: queuedProcesses, errors };\n\t}\n\n\tprivate normalizeExtensions(extensions: string[]): string[] {\n\t\treturn extensions.map((ext) =>\n\t\t\t(ext.startsWith(\".\") ? ext : `.${ext}`).toLowerCase(),\n\t\t);\n\t}\n\n\tprivate shouldCollectFile(\n\t\tentry: fs.Dirent,\n\t\tnormalizedExtensions: string[],\n\t\tfileNameRegex: RegExp,\n\t): boolean {\n\t\tconst fileExt = path.extname(entry.name).toLowerCase();\n\t\tconst matchesExtension =\n\t\t\tnormalizedExtensions.includes(\".*\") ||\n\t\t\tnormalizedExtensions.includes(fileExt);\n\t\tconst matchesFilenamePattern = fileNameRegex.test(entry.name);\n\n\t\treturn matchesExtension && matchesFilenamePattern;\n\t}\n\n\tprivate makeFilenameRegexp(fileNamePattern: string | RegExp): RegExp {\n\t\ttry {\n\t\t\treturn new RegExp(fileNamePattern);\n\t\t} catch {\n\t\t\tthrow new Error(`Invalid fileNamePattern: ${fileNamePattern}`);\n\t\t}\n\t}\n\n\tprivate makeExcludeRegExes(excludePatterns: string[] | RegExp[]): RegExp[] {\n\t\tif (excludePatterns.length === 0) {\n\t\t\treturn [];\n\t\t}\n\t\ttry {\n\t\t\treturn excludePatterns.map((pattern) => new RegExp(pattern));\n\t\t} catch (err) {\n\t\t\tthrow new Error(`Invalid excludePatterns: ${err}`);\n\t\t}\n\t}\n\n\tprivate async safeReadDir(dir: string): Promise<fs.Dirent[]> {\n\t\ttry {\n\t\t\treturn await fs.promises.readdir(dir, { withFileTypes: true });\n\t\t} catch {\n\t\t\tconsole.warn(`Skipping inaccessible directory: ${dir}`);\n\t\t\treturn [];\n\t\t}\n\t}\n\n\tprivate shouldExclude(filePath: string, excludeRegexes: RegExp[]): boolean {\n\t\treturn excludeRegexes.some((regex) => regex.test(filePath));\n\t}\n\n\tprivate makeQueue(inputDirs: string[]): string[] {\n\t\treturn [...inputDirs.map((dir) => path.resolve(dir))];\n\t}\n\n\tprivate async processCollectionQueue(\n\t\tqueue: string[],\n\t\texts: string[],\n\t\tnameRx: RegExp,\n\t\texcludeRx: RegExp[],\n\t\trecursive: boolean,\n\t): Promise<string[]> {\n\t\tconst found: string[] = [];\n\n\t\twhile (queue.length) {\n\t\t\tconst dir = queue.shift();\n\t\t\tif (!dir) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst entries = await this.safeReadDir(dir);\n\t\t\tfor (const entry of entries) {\n\t\t\t\tconst fullPath = path.resolve(dir, entry.name);\n\t\t\t\tthis.handleEntry(entry, fullPath, queue, found, {\n\t\t\t\t\texts,\n\t\t\t\t\tnameRx,\n\t\t\t\t\texcludeRx,\n\t\t\t\t\trecursive,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn found;\n\t}\n\n\tprivate handleEntry(\n\t\tentry: fs.Dirent,\n\t\tfullPath: string,\n\t\tqueue: string[],\n\t\tfound: string[],\n\t\topts: {\n\t\t\texts: string[];\n\t\t\tnameRx: RegExp;\n\t\t\texcludeRx: RegExp[];\n\t\t\trecursive: boolean;\n\t\t},\n\t): void {\n\t\tif (this.shouldExclude(fullPath, opts.excludeRx)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (entry.isDirectory()) {\n\t\t\tif (opts.recursive) {\n\t\t\t\tqueue.push(fullPath);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (\n\t\t\tentry.isFile() &&\n\t\t\tthis.shouldCollectFile(entry, opts.exts, opts.nameRx)\n\t\t) {\n\t\t\tfound.push(fullPath);\n\t\t}\n\t}\n}\n"],"mappings":"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","names":["process","fs","path","path","fs"]}
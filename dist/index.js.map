{"version":3,"sources":["../lib/services/LokaliseDownload.ts","../lib/errors/LokaliseError.ts","../lib/services/LokaliseFileExchange.ts","../lib/services/LokaliseUpload.ts"],"sourcesContent":["import fs from \"node:fs\";\nimport os from \"node:os\";\nimport path from \"node:path\";\nimport { pipeline } from \"node:stream\";\nimport { promisify } from \"node:util\";\nimport type {\n\tDownloadBundle,\n\tDownloadFileParams,\n\tQueuedProcess,\n} from \"@lokalise/node-api\";\nimport yauzl from \"yauzl\";\nimport { LokaliseError } from \"../errors/LokaliseError.js\";\nimport type { DownloadTranslationParams } from \"../interfaces/index.js\";\nimport { LokaliseFileExchange } from \"./LokaliseFileExchange.js\";\n\n/**\n * Handles downloading and extracting translation files from Lokalise.\n */\nexport class LokaliseDownload extends LokaliseFileExchange {\n\tprivate readonly streamPipeline = promisify(pipeline);\n\tprivate static readonly defaultProcessParams = {\n\t\tasyncDownload: false,\n\t\tpollInitialWaitTime: 1000,\n\t\tpollMaximumWaitTime: 120_000,\n\t\tbundleDownloadTimeout: undefined,\n\t};\n\n\t/**\n\t * Downloads translations from Lokalise, optionally using async polling, and extracts them to disk.\n\t *\n\t * @param downloadTranslationParams - Full configuration for the download process, extraction destination, and optional polling or timeout settings.\n\t * @throws {LokaliseError} If the download, polling, or extraction fails.\n\t */\n\tasync downloadTranslations({\n\t\tdownloadFileParams,\n\t\textractParams = {},\n\t\tprocessDownloadFileParams,\n\t}: DownloadTranslationParams): Promise<void> {\n\t\tconst {\n\t\t\tasyncDownload,\n\t\t\tpollInitialWaitTime,\n\t\t\tpollMaximumWaitTime,\n\t\t\tbundleDownloadTimeout,\n\t\t} = {\n\t\t\t...LokaliseDownload.defaultProcessParams,\n\t\t\t...processDownloadFileParams,\n\t\t};\n\n\t\tlet translationsBundleURL: string;\n\n\t\tif (asyncDownload) {\n\t\t\tconst downloadProcess =\n\t\t\t\tawait this.getTranslationsBundleAsync(downloadFileParams);\n\n\t\t\tconst completedProcess = (\n\t\t\t\tawait this.pollProcesses(\n\t\t\t\t\t[downloadProcess],\n\t\t\t\t\tpollInitialWaitTime,\n\t\t\t\t\tpollMaximumWaitTime,\n\t\t\t\t)\n\t\t\t)[0];\n\n\t\t\tif (completedProcess.status === \"finished\") {\n\t\t\t\ttranslationsBundleURL = completedProcess.details.download_url;\n\t\t\t} else {\n\t\t\t\tthrow new LokaliseError(\n\t\t\t\t\t`Download process took too long to finalize; gave up after ${pollMaximumWaitTime}ms`,\n\t\t\t\t\t500,\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tconst translationsBundle =\n\t\t\t\tawait this.getTranslationsBundle(downloadFileParams);\n\t\t\ttranslationsBundleURL = translationsBundle.bundle_url;\n\t\t}\n\n\t\tconst zipFilePath = await this.downloadZip(\n\t\t\ttranslationsBundleURL,\n\t\t\tbundleDownloadTimeout,\n\t\t);\n\n\t\ttry {\n\t\t\tawait this.unpackZip(\n\t\t\t\tzipFilePath,\n\t\t\t\tpath.resolve(extractParams.outputDir ?? \"./\"),\n\t\t\t);\n\t\t} finally {\n\t\t\tawait fs.promises.unlink(zipFilePath);\n\t\t}\n\t}\n\n\t/**\n\t * Unpacks a ZIP file into the specified directory.\n\t *\n\t * @param zipFilePath - Path to the ZIP file.\n\t * @param outputDir - Directory to extract the files into.\n\t * @throws {LokaliseError} If extraction fails or malicious paths are detected.\n\t */\n\tprotected async unpackZip(\n\t\tzipFilePath: string,\n\t\toutputDir: string,\n\t): Promise<void> {\n\t\tconst createDir = async (dir: string): Promise<void> => {\n\t\t\tawait fs.promises.mkdir(dir, { recursive: true });\n\t\t};\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tyauzl.open(zipFilePath, { lazyEntries: true }, async (err, zipfile) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn reject(\n\t\t\t\t\t\tnew LokaliseError(\n\t\t\t\t\t\t\t`Failed to open ZIP file at ${zipFilePath}: ${err.message}`,\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (!zipfile) {\n\t\t\t\t\treturn reject(\n\t\t\t\t\t\tnew LokaliseError(`ZIP file is invalid or empty: ${zipFilePath}`),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tzipfile.readEntry();\n\t\t\t\tzipfile.on(\"entry\", async (entry) => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Validate paths to avoid path traversal issues\n\t\t\t\t\t\tconst fullPath = path.resolve(outputDir, entry.fileName);\n\t\t\t\t\t\tconst relative = path.relative(outputDir, fullPath);\n\t\t\t\t\t\tif (relative.startsWith(\"..\") || path.isAbsolute(relative)) {\n\t\t\t\t\t\t\tthrow new LokaliseError(\n\t\t\t\t\t\t\t\t`Malicious ZIP entry detected: ${entry.fileName}`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (/\\/$/.test(entry.fileName)) {\n\t\t\t\t\t\t\t// Directory\n\t\t\t\t\t\t\tawait createDir(fullPath);\n\t\t\t\t\t\t\tzipfile.readEntry();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// File\n\t\t\t\t\t\t\tawait createDir(path.dirname(fullPath));\n\t\t\t\t\t\t\tconst writeStream = fs.createWriteStream(fullPath);\n\t\t\t\t\t\t\tzipfile.openReadStream(entry, (readErr, readStream) => {\n\t\t\t\t\t\t\t\tif (readErr || !readStream) {\n\t\t\t\t\t\t\t\t\treturn reject(\n\t\t\t\t\t\t\t\t\t\tnew LokaliseError(\n\t\t\t\t\t\t\t\t\t\t\t`Failed to read ZIP entry: ${entry.fileName}`,\n\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treadStream.pipe(writeStream);\n\t\t\t\t\t\t\t\twriteStream.on(\"finish\", () => zipfile.readEntry());\n\t\t\t\t\t\t\t\twriteStream.on(\"error\", reject);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\treturn reject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tzipfile.on(\"end\", () => resolve());\n\t\t\t\tzipfile.on(\"error\", reject);\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Downloads a ZIP file from the given URL.\n\t *\n\t * @param url - The URL of the ZIP file.\n\t * @returns The file path of the downloaded ZIP file.\n\t * @throws {LokaliseError} If the download fails or the response body is empty.\n\t */\n\tprotected async downloadZip(\n\t\turl: string,\n\t\tdownloadTimeout: number | undefined,\n\t): Promise<string> {\n\t\tif (!/^https?:\\/\\//.test(url)) {\n\t\t\tthrow new LokaliseError(`Invalid URL: ${url}`);\n\t\t}\n\n\t\tconst tempZipPath = path.join(\n\t\t\tos.tmpdir(),\n\t\t\t`lokalise-translations-${Date.now()}.zip`,\n\t\t);\n\n\t\tconst controller = new AbortController();\n\t\tlet timeoutId: NodeJS.Timeout | null = null;\n\t\tlet response: Response;\n\n\t\tif (downloadTimeout && downloadTimeout > 0) {\n\t\t\ttimeoutId = setTimeout(() => controller.abort(), downloadTimeout);\n\t\t}\n\n\t\ttry {\n\t\t\tresponse = await fetch(url, {\n\t\t\t\tsignal: controller.signal,\n\t\t\t});\n\t\t} catch (err) {\n\t\t\tif (err instanceof Error) {\n\t\t\t\tif (err.name === \"AbortError\") {\n\t\t\t\t\tthrow new LokaliseError(\n\t\t\t\t\t\t`Request timed out after ${downloadTimeout}ms`,\n\t\t\t\t\t\t408,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treason: \"timeout\",\n\t\t\t\t\t\t},\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tthrow new LokaliseError(err.message, 500, {\n\t\t\t\t\treason: \"network or fetch error\",\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthrow new LokaliseError(\"An unknown error occurred\", 500, {\n\t\t\t\treason: String(err),\n\t\t\t});\n\t\t} finally {\n\t\t\tif (timeoutId) {\n\t\t\t\tclearTimeout(timeoutId);\n\t\t\t}\n\t\t}\n\n\t\tif (!response.ok) {\n\t\t\tthrow new LokaliseError(\n\t\t\t\t`Failed to download ZIP file: ${response.statusText} (${response.status})`,\n\t\t\t);\n\t\t}\n\n\t\tconst body = response.body;\n\t\tif (!body) {\n\t\t\tthrow new LokaliseError(\n\t\t\t\t`Response body is null. Cannot download ZIP file from URL: ${url}`,\n\t\t\t);\n\t\t}\n\n\t\tawait this.streamPipeline(body, fs.createWriteStream(tempZipPath));\n\t\treturn tempZipPath;\n\t}\n\n\t/**\n\t * Retrieves a translation bundle from Lokalise with retries and exponential backoff.\n\t *\n\t * @param downloadFileParams - Parameters for Lokalise API file download.\n\t * @returns The downloaded bundle metadata.\n\t * @throws {LokaliseError} If retries are exhausted or an API error occurs.\n\t */\n\tprotected async getTranslationsBundle(\n\t\tdownloadFileParams: DownloadFileParams,\n\t): Promise<DownloadBundle> {\n\t\treturn this.withExponentialBackoff(() =>\n\t\t\tthis.apiClient.files().download(this.projectId, downloadFileParams),\n\t\t);\n\t}\n\n\t/**\n\t * Retrieves a translation bundle from Lokalise with retries and exponential backoff.\n\t *\n\t * @param downloadFileParams - Parameters for Lokalise API file download.\n\t * @returns The queued process.\n\t * @throws {LokaliseError} If retries are exhausted or an API error occurs.\n\t */\n\tprotected async getTranslationsBundleAsync(\n\t\tdownloadFileParams: DownloadFileParams,\n\t): Promise<QueuedProcess> {\n\t\treturn this.withExponentialBackoff(() =>\n\t\t\tthis.apiClient.files().async_download(this.projectId, downloadFileParams),\n\t\t);\n\t}\n}\n","import type { LokaliseError as ILokaliseError } from \"../interfaces/LokaliseError.js\";\n\n/**\n * Represents a custom error.\n */\nexport class LokaliseError extends Error implements ILokaliseError {\n\t/**\n\t * The error code representing the type of Lokalise API error.\n\t */\n\tcode?: number;\n\n\t/**\n\t * Additional details about the error.\n\t */\n\tdetails?: Record<string, string | number>;\n\n\t/**\n\t * Creates a new instance of LokaliseError.\n\t *\n\t * @param message - The error message.\n\t * @param code - The error code (optional).\n\t * @param details - Optional additional details about the error.\n\t */\n\tconstructor(\n\t\tmessage: string,\n\t\tcode?: number,\n\t\tdetails?: Record<string, string | number>,\n\t) {\n\t\tsuper(message);\n\t\tthis.code = code;\n\t\tthis.details = details;\n\t}\n\n\t/**\n\t * Returns a string representation of the error, including code and details.\n\t *\n\t * @returns The formatted error message.\n\t */\n\toverride toString(): string {\n\t\tlet baseMessage = `LokaliseError: ${this.message}`;\n\t\tif (this.code) {\n\t\t\tbaseMessage += ` (Code: ${this.code})`;\n\t\t}\n\t\tif (this.details) {\n\t\t\tconst formattedDetails = Object.entries(this.details)\n\t\t\t\t.map(([key, value]) => `${key}: ${value}`)\n\t\t\t\t.join(\", \");\n\n\t\t\tbaseMessage += ` | Details: ${formattedDetails}`;\n\t\t}\n\t\treturn baseMessage;\n\t}\n}\n","import {\n\tLokaliseApi,\n\tApiError as LokaliseApiError,\n\tLokaliseApiOAuth,\n} from \"@lokalise/node-api\";\nimport type { ClientParams, QueuedProcess } from \"@lokalise/node-api\";\nimport { LokaliseError } from \"../errors/LokaliseError.js\";\nimport type {\n\tLokaliseExchangeConfig,\n\tRetryParams,\n} from \"../interfaces/index.js\";\n\n/**\n * A utility class for exchanging files with the Lokalise API.\n */\nexport class LokaliseFileExchange {\n\t/**\n\t * The Lokalise API client instance.\n\t */\n\tpublic readonly apiClient: LokaliseApi;\n\n\t/**\n\t * The ID of the project in Lokalise.\n\t */\n\tprotected readonly projectId: string;\n\n\t/**\n\t * Retry parameters for API requests.\n\t */\n\tprotected readonly retryParams: RetryParams;\n\n\t/**\n\t * Default retry parameters for API requests.\n\t */\n\tprivate static readonly defaultRetryParams: RetryParams = {\n\t\tmaxRetries: 3,\n\t\tinitialSleepTime: 1000,\n\t};\n\n\tprivate readonly PENDING_STATUSES = [\n\t\t\"queued\",\n\t\t\"pre_processing\",\n\t\t\"running\",\n\t\t\"post_processing\",\n\t];\n\tprivate readonly FINISHED_STATUSES = [\"finished\", \"cancelled\", \"failed\"];\n\n\tprivate readonly RETRYABLE_CODES = [408, 429];\n\n\t/**\n\t * Creates a new instance of LokaliseFileExchange.\n\t *\n\t * @param clientConfig - Configuration for the Lokalise SDK.\n\t * @param exchangeConfig - The configuration object for file exchange operations.\n\t * @throws {LokaliseError} If the provided configuration is invalid.\n\t */\n\tconstructor(\n\t\tclientConfig: ClientParams,\n\t\t{ projectId, useOAuth2 = false, retryParams }: LokaliseExchangeConfig,\n\t) {\n\t\tif (!clientConfig.apiKey || typeof clientConfig.apiKey !== \"string\") {\n\t\t\tthrow new LokaliseError(\"Invalid or missing API token.\");\n\t\t}\n\t\tif (useOAuth2) {\n\t\t\tthis.apiClient = new LokaliseApiOAuth(clientConfig);\n\t\t} else {\n\t\t\tthis.apiClient = new LokaliseApi(clientConfig);\n\t\t}\n\n\t\tif (!projectId || typeof projectId !== \"string\") {\n\t\t\tthrow new LokaliseError(\"Invalid or missing Project ID.\");\n\t\t}\n\t\tthis.projectId = projectId;\n\n\t\tthis.retryParams = {\n\t\t\t...LokaliseFileExchange.defaultRetryParams,\n\t\t\t...retryParams,\n\t\t};\n\n\t\tif (this.retryParams.maxRetries < 0) {\n\t\t\tthrow new LokaliseError(\n\t\t\t\t\"maxRetries must be greater than or equal to zero.\",\n\t\t\t);\n\t\t}\n\t\tif (this.retryParams.initialSleepTime <= 0) {\n\t\t\tthrow new LokaliseError(\"initialSleepTime must be a positive value.\");\n\t\t}\n\t}\n\n\t/**\n\t * Executes an asynchronous operation with exponential backoff retry logic.\n\t *\n\t * Retries the provided operation in the event of specific retryable errors (e.g., 429 Too Many Requests,\n\t * 408 Request Timeout) using an exponential backoff strategy with optional jitter. If the maximum number\n\t * of retries is exceeded, it throws an error. Non-retryable errors are immediately propagated.\n\t *\n\t * @template T The type of the value returned by the operation.\n\t * @param operation - The asynchronous operation to execute.\n\t * @returns A promise that resolves to the result of the operation if successful.\n\t * @throws {LokaliseError} If the maximum number of retries is reached or a non-retryable error occurs.\n\t */\n\tprotected async withExponentialBackoff<T>(\n\t\toperation: () => Promise<T>,\n\t): Promise<T> {\n\t\tconst { maxRetries, initialSleepTime } = this.retryParams;\n\n\t\tfor (let attempt = 1; attempt <= maxRetries + 1; attempt++) {\n\t\t\ttry {\n\t\t\t\treturn await operation();\n\t\t\t} catch (error: unknown) {\n\t\t\t\tif (\n\t\t\t\t\terror instanceof LokaliseApiError &&\n\t\t\t\t\tthis.RETRYABLE_CODES.includes(error.code)\n\t\t\t\t) {\n\t\t\t\t\tif (attempt === maxRetries + 1) {\n\t\t\t\t\t\tthrow new LokaliseError(\n\t\t\t\t\t\t\t`Maximum retries reached: ${error.message ?? \"Unknown error\"}`,\n\t\t\t\t\t\t\terror.code,\n\t\t\t\t\t\t\terror.details,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tawait this.sleep(initialSleepTime * 2 ** (attempt - 1));\n\t\t\t\t} else if (error instanceof LokaliseApiError) {\n\t\t\t\t\tthrow new LokaliseError(error.message, error.code, error.details);\n\t\t\t\t} else {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// This line is unreachable but keeps TS happy.\n\t\tthrow new LokaliseError(\"Unexpected error during operation.\", 500);\n\t}\n\n\t/**\n\t * Polls the status of queued processes until they are marked as \"finished\" or until the maximum wait time is exceeded.\n\t *\n\t * @param {QueuedProcess[]} processes - The array of processes to poll.\n\t * @param {number} initialWaitTime - The initial wait time before polling in milliseconds.\n\t * @param {number} maxWaitTime - The maximum time to wait for processes in milliseconds.\n\t * @returns {Promise<QueuedProcess[]>} A promise resolving to the updated array of processes with their final statuses.\n\t */\n\tprotected async pollProcesses(\n\t\tprocesses: QueuedProcess[],\n\t\tinitialWaitTime: number,\n\t\tmaxWaitTime: number,\n\t): Promise<QueuedProcess[]> {\n\t\tconst startTime = Date.now();\n\t\tlet waitTime = initialWaitTime;\n\n\t\tconst processMap = new Map<string, QueuedProcess>();\n\n\t\t// Initialize processMap and set a default status if missing\n\t\tconst pendingProcessIds = new Set<string>();\n\n\t\tfor (const process of processes) {\n\t\t\tif (!process.status) {\n\t\t\t\tprocess.status = \"queued\"; // Assign default status if missing\n\t\t\t}\n\n\t\t\tprocessMap.set(process.process_id, process);\n\n\t\t\tif (this.PENDING_STATUSES.includes(process.status)) {\n\t\t\t\tpendingProcessIds.add(process.process_id);\n\t\t\t}\n\t\t}\n\n\t\twhile (pendingProcessIds.size > 0 && Date.now() - startTime < maxWaitTime) {\n\t\t\tawait Promise.all(\n\t\t\t\t[...pendingProcessIds].map(async (processId) => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst updatedProcess = await this.apiClient\n\t\t\t\t\t\t\t.queuedProcesses()\n\t\t\t\t\t\t\t.get(processId, { project_id: this.projectId });\n\n\t\t\t\t\t\tif (!updatedProcess.status) {\n\t\t\t\t\t\t\tupdatedProcess.status = \"queued\"; // Ensure missing status is defaulted\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tprocessMap.set(processId, updatedProcess);\n\n\t\t\t\t\t\tif (this.FINISHED_STATUSES.includes(updatedProcess.status)) {\n\t\t\t\t\t\t\tpendingProcessIds.delete(processId);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (_error) {\n\t\t\t\t\t\t// console.warn(`Failed to fetch process ${processId}:`, error);\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\tif (\n\t\t\t\tpendingProcessIds.size === 0 ||\n\t\t\t\tDate.now() - startTime >= maxWaitTime\n\t\t\t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tawait this.sleep(waitTime);\n\t\t\twaitTime = Math.min(waitTime * 2, maxWaitTime - (Date.now() - startTime));\n\t\t}\n\n\t\treturn Array.from(processMap.values());\n\t}\n\n\t/**\n\t * Pauses execution for the specified number of milliseconds.\n\t *\n\t * @param ms - The time to sleep in milliseconds.\n\t * @returns A promise that resolves after the specified time.\n\t */\n\tprotected sleep(ms: number): Promise<void> {\n\t\treturn new Promise((resolve) => setTimeout(resolve, ms));\n\t}\n}\n","import fs from \"node:fs\";\nimport path from \"node:path\";\nimport type { QueuedProcess, UploadFileParams } from \"@lokalise/node-api\";\nimport type {\n\tCollectFileParams,\n\tFileUploadError,\n\tPartialUploadFileParams,\n\tProcessUploadFileParams,\n\tProcessedFile,\n\tQueuedUploadProcessesWithErrors,\n\tUploadTranslationParams,\n} from \"../interfaces/index.js\";\nimport { LokaliseFileExchange } from \"./LokaliseFileExchange.js\";\n\n/**\n * Handles uploading translation files to Lokalise.\n */\nexport class LokaliseUpload extends LokaliseFileExchange {\n\tprivate readonly maxConcurrentProcesses = 6;\n\n\tprivate static readonly defaultPollingParams = {\n\t\tpollStatuses: false,\n\t\tpollInitialWaitTime: 1000,\n\t\tpollMaximumWaitTime: 120_000,\n\t};\n\n\t/**\n\t * Collects files, uploads them to Lokalise, and optionally polls for process completion, returning both processes and errors.\n\t *\n\t * @param {UploadTranslationParams} uploadTranslationParams - Parameters for collecting and uploading files.\n\t * @returns {Promise<{ processes: QueuedProcess[]; errors: FileUploadError[] }>} A promise resolving with successful processes and upload errors.\n\t */\n\tasync uploadTranslations({\n\t\tuploadFileParams,\n\t\tcollectFileParams,\n\t\tprocessUploadFileParams,\n\t}: UploadTranslationParams = {}): Promise<QueuedUploadProcessesWithErrors> {\n\t\tconst { pollStatuses, pollInitialWaitTime, pollMaximumWaitTime } = {\n\t\t\t...LokaliseUpload.defaultPollingParams,\n\t\t\t...processUploadFileParams,\n\t\t};\n\n\t\tconst collectedFiles = await this.collectFiles(collectFileParams);\n\n\t\tconst { processes, errors } = await this.parallelUpload(\n\t\t\tcollectedFiles,\n\t\t\tuploadFileParams,\n\t\t\tprocessUploadFileParams,\n\t\t);\n\n\t\tlet completedProcesses = processes;\n\n\t\tif (pollStatuses) {\n\t\t\tcompletedProcesses = await this.pollProcesses(\n\t\t\t\tprocesses,\n\t\t\t\tpollInitialWaitTime,\n\t\t\t\tpollMaximumWaitTime,\n\t\t\t);\n\t\t}\n\n\t\treturn { processes: completedProcesses, errors };\n\t}\n\n\t/**\n\t * Collects files from the filesystem based on the given parameters.\n\t *\n\t * @param {CollectFileParams} collectFileParams - Parameters for file collection, including directories, extensions, and patterns.\n\t * @returns {Promise<string[]>} A promise resolving with the list of collected file paths.\n\t */\n\tprotected async collectFiles({\n\t\tinputDirs = [\"./locales\"],\n\t\textensions = [\".*\"],\n\t\texcludePatterns = [],\n\t\trecursive = true,\n\t\tfileNamePattern = \".*\",\n\t}: CollectFileParams = {}): Promise<string[]> {\n\t\tconst collectedFiles: string[] = [];\n\t\tconst queue: string[] = [...inputDirs.map((dir) => path.resolve(dir))];\n\n\t\tconst normalizedExtensions = extensions.map((ext) =>\n\t\t\text.startsWith(\".\") ? ext : `.${ext}`,\n\t\t);\n\n\t\tlet fileNameRegex: RegExp;\n\t\ttry {\n\t\t\tfileNameRegex = new RegExp(fileNamePattern);\n\t\t} catch {\n\t\t\tthrow new Error(`Invalid fileNamePattern: ${fileNamePattern}`);\n\t\t}\n\n\t\tlet excludeRegexes: RegExp[] = [];\n\t\ttry {\n\t\t\texcludeRegexes = excludePatterns.map((pattern) => new RegExp(pattern));\n\t\t} catch (err) {\n\t\t\tthrow new Error(`Invalid excludePatterns: ${err}`);\n\t\t}\n\n\t\twhile (queue.length > 0) {\n\t\t\tconst dir = queue.shift();\n\t\t\tif (!dir) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet entries: fs.Dirent[];\n\t\t\ttry {\n\t\t\t\tentries = await fs.promises.readdir(dir, { withFileTypes: true });\n\t\t\t} catch {\n\t\t\t\tconsole.warn(`Skipping inaccessible directory: ${dir}`);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (const entry of entries) {\n\t\t\t\tconst fullPath = path.resolve(dir, entry.name);\n\n\t\t\t\tif (excludeRegexes.some((regex) => regex.test(fullPath))) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (entry.isDirectory() && recursive) {\n\t\t\t\t\tqueue.push(fullPath);\n\t\t\t\t} else if (entry.isFile()) {\n\t\t\t\t\tconst fileExt = path.extname(entry.name);\n\t\t\t\t\tconst matchesExtension =\n\t\t\t\t\t\tnormalizedExtensions.includes(\".*\") ||\n\t\t\t\t\t\tnormalizedExtensions.includes(fileExt);\n\t\t\t\t\tconst matchesFilenamePattern = fileNameRegex.test(entry.name);\n\n\t\t\t\t\tif (matchesExtension && matchesFilenamePattern) {\n\t\t\t\t\t\tcollectedFiles.push(fullPath);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn collectedFiles.sort(); // Ensure deterministic output\n\t}\n\n\t/**\n\t * Uploads a single file to Lokalise.\n\t *\n\t * @param {UploadFileParams} uploadParams - Parameters for uploading the file.\n\t * @returns {Promise<QueuedProcess>} A promise resolving with the upload process details.\n\t */\n\tprotected async uploadSingleFile(\n\t\tuploadParams: UploadFileParams,\n\t): Promise<QueuedProcess> {\n\t\treturn this.withExponentialBackoff(() =>\n\t\t\tthis.apiClient.files().upload(this.projectId, uploadParams),\n\t\t);\n\t}\n\n\t/**\n\t * Processes a file to prepare it for upload, converting it to base64 and extracting its language code.\n\t *\n\t * @param {string} file - The absolute path to the file.\n\t * @param {string} projectRoot - The root directory of the project.\n\t * @param {ProcessUploadFileParams} [processParams] - Optional processing settings including inferers.\n\t * @returns {Promise<ProcessedFile>} A promise resolving with the processed file details, including base64 content, relative path, and language code.\n\t */\n\tprotected async processFile(\n\t\tfile: string,\n\t\tprojectRoot: string,\n\t\tprocessParams?: ProcessUploadFileParams,\n\t): Promise<ProcessedFile> {\n\t\tlet relativePath: string;\n\t\ttry {\n\t\t\trelativePath = processParams?.filenameInferer\n\t\t\t\t? await processParams.filenameInferer(file)\n\t\t\t\t: \"\";\n\t\t\tif (!relativePath.trim()) {\n\t\t\t\tthrow new Error(\"Invalid filename: empty or only whitespace\");\n\t\t\t}\n\t\t} catch {\n\t\t\tconst toPosixPath = (p: string) => p.split(path.sep).join(path.posix.sep);\n\t\t\trelativePath = path.posix.relative(\n\t\t\t\ttoPosixPath(projectRoot),\n\t\t\t\ttoPosixPath(file),\n\t\t\t);\n\t\t}\n\n\t\tlet languageCode: string;\n\t\ttry {\n\t\t\tlanguageCode = processParams?.languageInferer\n\t\t\t\t? await processParams.languageInferer(file)\n\t\t\t\t: \"\";\n\t\t\tif (!languageCode.trim()) {\n\t\t\t\tthrow new Error(\"Invalid language code: empty or only whitespace\");\n\t\t\t}\n\t\t} catch {\n\t\t\tlanguageCode = path.parse(path.basename(relativePath)).name;\n\t\t}\n\n\t\tconst fileContent = await fs.promises.readFile(file);\n\n\t\treturn {\n\t\t\tdata: fileContent.toString(\"base64\"),\n\t\t\tfilename: relativePath,\n\t\t\tlang_iso: languageCode,\n\t\t};\n\t}\n\n\t/**\n\t * Uploads files in parallel with a limit on the number of concurrent uploads.\n\t *\n\t * @param {string[]} files - List of file paths to upload.\n\t * @param {Partial<UploadFileParams>} baseUploadFileParams - Base parameters for uploads.\n\t * @param {ProcessUploadFileParams} [processParams] - Optional processing settings including inferers.\n\t * @returns {Promise<{ processes: QueuedProcess[]; errors: FileUploadError[] }>} A promise resolving with successful processes and upload errors.\n\t */\n\tprivate async parallelUpload(\n\t\tfiles: string[],\n\t\tbaseUploadFileParams: PartialUploadFileParams = {},\n\t\tprocessParams?: ProcessUploadFileParams,\n\t): Promise<QueuedUploadProcessesWithErrors> {\n\t\tconst projectRoot = process.cwd();\n\t\tconst queuedProcesses: QueuedProcess[] = [];\n\t\tconst errors: FileUploadError[] = [];\n\n\t\tconst pool = new Array(this.maxConcurrentProcesses).fill(null).map(() =>\n\t\t\t(async () => {\n\t\t\t\twhile (files.length > 0) {\n\t\t\t\t\tconst file = files.shift();\n\t\t\t\t\tif (!file) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst processedFileParams = await this.processFile(\n\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\tprojectRoot,\n\t\t\t\t\t\t\tprocessParams,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst queuedProcess = await this.uploadSingleFile({\n\t\t\t\t\t\t\t...baseUploadFileParams,\n\t\t\t\t\t\t\t...processedFileParams,\n\t\t\t\t\t\t});\n\t\t\t\t\t\tqueuedProcesses.push(queuedProcess);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\terrors.push({ file, error });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})(),\n\t\t);\n\n\t\tawait Promise.all(pool);\n\t\treturn { processes: queuedProcesses, errors };\n\t}\n}\n"],"mappings":"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","names":["process","fs","path","path","fs"]}
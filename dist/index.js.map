{"version":3,"sources":["../lib/errors/LokaliseError.ts","../lib/services/LokaliseDownload.ts","../lib/services/LokaliseFileExchange.ts","../lib/services/LokaliseUpload.ts"],"sourcesContent":["import type { LokaliseError as ILokaliseError } from \"../interfaces/LokaliseError.js\";\n\n/**\n * Represents a custom error.\n */\nexport class LokaliseError extends Error implements ILokaliseError {\n\t/**\n\t * The error code representing the type of Lokalise API error.\n\t */\n\tcode?: number | undefined;\n\n\t/**\n\t * Additional details about the error.\n\t */\n\tdetails?: Record<string, string | number | boolean>;\n\n\t/**\n\t * Creates a new instance of LokaliseError.\n\t *\n\t * @param message - The error message.\n\t * @param code - The error code (optional).\n\t * @param details - Optional additional details about the error.\n\t */\n\tconstructor(\n\t\tmessage: string,\n\t\tcode?: number,\n\t\tdetails?: Record<string, string | number | boolean>,\n\t) {\n\t\tsuper(message);\n\t\tthis.code = code;\n\n\t\tif (details) {\n\t\t\tthis.details = details;\n\t\t}\n\t}\n\n\t/**\n\t * Returns a string representation of the error, including code and details.\n\t *\n\t * @returns The formatted error message.\n\t */\n\toverride toString(): string {\n\t\tlet baseMessage = `LokaliseError: ${this.message}`;\n\t\tif (this.code) {\n\t\t\tbaseMessage += ` (Code: ${this.code})`;\n\t\t}\n\t\tif (this.details) {\n\t\t\tconst formattedDetails = Object.entries(this.details)\n\t\t\t\t.map(([key, value]) => `${key}: ${value}`)\n\t\t\t\t.join(\", \");\n\n\t\t\tbaseMessage += ` | Details: ${formattedDetails}`;\n\t\t}\n\t\treturn baseMessage;\n\t}\n}\n","import crypto from \"node:crypto\";\nimport fs from \"node:fs\";\nimport os from \"node:os\";\nimport path from \"node:path\";\nimport { pipeline, Readable } from \"node:stream\";\nimport type { ReadableStream as WebReadableStream } from \"node:stream/web\";\nimport { promisify } from \"node:util\";\nimport type {\n\tDownloadBundle,\n\tDownloadedFileProcessDetails,\n\tDownloadFileParams,\n\tQueuedProcess,\n} from \"@lokalise/node-api\";\nimport yauzl from \"yauzl\";\nimport { LokaliseError } from \"../errors/LokaliseError.js\";\nimport type { DownloadTranslationParams } from \"../interfaces/index.js\";\nimport { LokaliseFileExchange } from \"./LokaliseFileExchange.js\";\n\n/**\n * Handles downloading and extracting translation files from Lokalise.\n */\nexport class LokaliseDownload extends LokaliseFileExchange {\n\tprivate static readonly defaultProcessParams = {\n\t\tasyncDownload: false,\n\t\tpollInitialWaitTime: 1000,\n\t\tpollMaximumWaitTime: 120_000,\n\t\tbundleDownloadTimeout: 0,\n\t};\n\n\tprivate readonly streamPipeline = promisify(pipeline);\n\n\t/**\n\t * Downloads translations from Lokalise, optionally using async polling, and extracts them to disk.\n\t *\n\t * @param downloadTranslationParams - Full configuration for the download process, extraction destination, and optional polling or timeout settings.\n\t * @throws {LokaliseError} If the download, polling, or extraction fails.\n\t */\n\tasync downloadTranslations({\n\t\tdownloadFileParams,\n\t\textractParams = {},\n\t\tprocessDownloadFileParams,\n\t}: DownloadTranslationParams): Promise<void> {\n\t\tthis.logMsg(\"debug\", \"Downloading translations from Lokalise...\");\n\n\t\tconst {\n\t\t\tasyncDownload,\n\t\t\tpollInitialWaitTime,\n\t\t\tpollMaximumWaitTime,\n\t\t\tbundleDownloadTimeout,\n\t\t} = {\n\t\t\t...LokaliseDownload.defaultProcessParams,\n\t\t\t...processDownloadFileParams,\n\t\t};\n\n\t\tlet translationsBundleURL: string;\n\n\t\tif (asyncDownload) {\n\t\t\tthis.logMsg(\"debug\", \"Async download mode enabled.\");\n\n\t\t\tconst downloadProcess =\n\t\t\t\tawait this.getTranslationsBundleAsync(downloadFileParams);\n\n\t\t\tthis.logMsg(\n\t\t\t\t\"debug\",\n\t\t\t\t`Waiting for download process ID ${downloadProcess.process_id} to complete...`,\n\t\t\t);\n\t\t\tthis.logMsg(\n\t\t\t\t\"debug\",\n\t\t\t\t`Effective waits: initial=${pollInitialWaitTime}ms, max=${pollMaximumWaitTime}ms`,\n\t\t\t);\n\n\t\t\tconst results = await this.pollProcesses(\n\t\t\t\t[downloadProcess],\n\t\t\t\tpollInitialWaitTime,\n\t\t\t\tpollMaximumWaitTime,\n\t\t\t);\n\n\t\t\tconst completedProcess = results.find(\n\t\t\t\t(p) => p.process_id === downloadProcess.process_id,\n\t\t\t);\n\n\t\t\tif (!completedProcess) {\n\t\t\t\tthrow new LokaliseError(\n\t\t\t\t\t`Process ${downloadProcess.process_id} not found after polling`,\n\t\t\t\t\t500,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (!LokaliseFileExchange.isFinishedStatus(completedProcess.status)) {\n\t\t\t\tthrow new LokaliseError(\n\t\t\t\t\t`Download process did not finish within ${pollMaximumWaitTime}ms` +\n\t\t\t\t\t\t`${completedProcess.status ? ` (last status=${completedProcess.status})` : \" (status missing)\"}`,\n\t\t\t\t\t504,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis.logMsg(\n\t\t\t\t\"debug\",\n\t\t\t\t`Download process status is ${completedProcess.status}`,\n\t\t\t);\n\n\t\t\tif (completedProcess.status === \"finished\") {\n\t\t\t\tconst details = completedProcess.details as\n\t\t\t\t\t| (DownloadedFileProcessDetails & { download_url?: string })\n\t\t\t\t\t| undefined;\n\n\t\t\t\tconst url = details?.download_url;\n\t\t\t\tif (!url || typeof url !== \"string\") {\n\t\t\t\t\tthis.logMsg(\n\t\t\t\t\t\t\"warn\",\n\t\t\t\t\t\t\"Process finished but details.download_url is missing or invalid\",\n\t\t\t\t\t\tdetails,\n\t\t\t\t\t);\n\t\t\t\t\tthrow new LokaliseError(\n\t\t\t\t\t\t\"Lokalise returned finished process without a valid download_url\",\n\t\t\t\t\t\t502,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\ttranslationsBundleURL = url;\n\t\t\t} else if (\n\t\t\t\tcompletedProcess.status === \"failed\" ||\n\t\t\t\tcompletedProcess.status === \"cancelled\"\n\t\t\t) {\n\t\t\t\tconst msg = completedProcess.message?.trim();\n\t\t\t\tthrow new LokaliseError(\n\t\t\t\t\t`Process ${completedProcess.process_id} ended with status=${completedProcess.status}` +\n\t\t\t\t\t\t(msg ? `: ${msg}` : \"\"),\n\t\t\t\t\t502,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthis.logMsg(\n\t\t\t\t\t\"warn\",\n\t\t\t\t\t`Process ended with status=${completedProcess.status}`,\n\t\t\t\t);\n\t\t\t\tthrow new LokaliseError(\n\t\t\t\t\t`Download process took too long to finalize; ` +\n\t\t\t\t\t\t`configured=${String(processDownloadFileParams?.pollMaximumWaitTime)} ` +\n\t\t\t\t\t\t`effective=${pollMaximumWaitTime}ms`,\n\t\t\t\t\t500,\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.logMsg(\"debug\", \"Async download mode disabled.\");\n\n\t\t\tconst translationsBundle =\n\t\t\t\tawait this.getTranslationsBundle(downloadFileParams);\n\t\t\ttranslationsBundleURL = translationsBundle.bundle_url;\n\t\t}\n\n\t\tthis.logMsg(\"debug\", \"Downloading translation bundle...\");\n\n\t\tconst zipFilePath = await this.downloadZip(\n\t\t\ttranslationsBundleURL,\n\t\t\tbundleDownloadTimeout,\n\t\t);\n\n\t\tconst unpackTo = path.resolve(extractParams.outputDir ?? \"./\");\n\n\t\tthis.logMsg(\n\t\t\t\"debug\",\n\t\t\t`Unpacking translations from ${zipFilePath} to ${unpackTo}`,\n\t\t);\n\n\t\ttry {\n\t\t\tawait this.unpackZip(zipFilePath, unpackTo);\n\n\t\t\tthis.logMsg(\"debug\", \"Translations unpacked!\");\n\t\t\tthis.logMsg(\"debug\", \"Download successful!\");\n\t\t} finally {\n\t\t\tthis.logMsg(\"debug\", `Removing temp archive from ${zipFilePath}`);\n\t\t\tawait fs.promises.unlink(zipFilePath);\n\t\t}\n\t}\n\n\t/**\n\t * Unpacks a ZIP file into the specified directory.\n\t *\n\t * @param zipFilePath - Path to the ZIP file.\n\t * @param outputDir - Directory to extract the files into.\n\t * @throws {LokaliseError} If extraction fails or malicious paths are detected.\n\t */\n\tprotected async unpackZip(\n\t\tzipFilePath: string,\n\t\toutputDir: string,\n\t): Promise<void> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tyauzl.open(zipFilePath, { lazyEntries: true }, (err, zipfile) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn reject(\n\t\t\t\t\t\tnew LokaliseError(\n\t\t\t\t\t\t\t`Failed to open ZIP file at ${zipFilePath}: ${err.message}`,\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (!zipfile) {\n\t\t\t\t\treturn reject(\n\t\t\t\t\t\tnew LokaliseError(`ZIP file is invalid or empty: ${zipFilePath}`),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tzipfile.readEntry();\n\n\t\t\t\tzipfile.on(\"entry\", (entry) => {\n\t\t\t\t\tthis.handleZipEntry(entry, zipfile, outputDir)\n\t\t\t\t\t\t.then(() => zipfile.readEntry())\n\t\t\t\t\t\t.catch(reject);\n\t\t\t\t});\n\n\t\t\t\tzipfile.on(\"end\", resolve);\n\t\t\t\tzipfile.on(\"error\", reject);\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Downloads a ZIP file from the given URL.\n\t *\n\t * @param url - The URL of the ZIP file.\n\t * @returns The file path of the downloaded ZIP file.\n\t * @throws {LokaliseError} If the download fails or the response body is empty.\n\t */\n\tprotected async downloadZip(\n\t\turl: string,\n\t\tdownloadTimeout = 0,\n\t): Promise<string> {\n\t\tconst bundleURL = this.assertHttpUrl(url);\n\n\t\tconst uid =\n\t\t\tcrypto.randomUUID?.() ??\n\t\t\t`${process.pid}-${Date.now()}-${crypto.randomBytes(8).toString(\"hex\")}`;\n\n\t\tconst tempZipPath = path.join(os.tmpdir(), `lokalise-${uid}.zip`);\n\t\tlet response: Response;\n\n\t\tconst signal =\n\t\t\tdownloadTimeout > 0 ? AbortSignal.timeout(downloadTimeout) : undefined;\n\n\t\ttry {\n\t\t\tresponse = await fetch(bundleURL, {\n\t\t\t\t...(signal ? { signal } : {}),\n\t\t\t});\n\t\t} catch (err) {\n\t\t\tif (err instanceof Error) {\n\t\t\t\tif (err.name === \"TimeoutError\") {\n\t\t\t\t\tthrow new LokaliseError(\n\t\t\t\t\t\t`Request timed out after ${downloadTimeout}ms`,\n\t\t\t\t\t\t408,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treason: \"timeout\",\n\t\t\t\t\t\t},\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tthrow new LokaliseError(err.message, 500, {\n\t\t\t\t\treason: \"network or fetch error\",\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthrow new LokaliseError(\"An unknown error occurred\", 500, {\n\t\t\t\treason: String(err),\n\t\t\t});\n\t\t}\n\n\t\tif (!response.ok) {\n\t\t\tthrow new LokaliseError(\n\t\t\t\t`Failed to download ZIP file: ${response.statusText} (${response.status})`,\n\t\t\t);\n\t\t}\n\n\t\tconst body = response.body;\n\t\tif (!body) {\n\t\t\tthrow new LokaliseError(\n\t\t\t\t`Response body is null. Cannot download ZIP file from URL: ${url}`,\n\t\t\t);\n\t\t}\n\n\t\ttry {\n\t\t\tconst nodeReadable = Readable.fromWeb(\n\t\t\t\tbody as unknown as WebReadableStream<Uint8Array>,\n\t\t\t);\n\t\t\tawait this.streamPipeline(\n\t\t\t\tnodeReadable,\n\t\t\t\tfs.createWriteStream(tempZipPath),\n\t\t\t);\n\t\t} catch (e) {\n\t\t\ttry {\n\t\t\t\tawait fs.promises.unlink(tempZipPath);\n\t\t\t} catch {\n\t\t\t\tthis.logMsg(\n\t\t\t\t\t\"debug\",\n\t\t\t\t\t`Stream pipeline failed and unable to remove temp path ${tempZipPath}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\tthrow e;\n\t\t}\n\t\treturn tempZipPath;\n\t}\n\n\t/**\n\t * Retrieves a translation bundle from Lokalise with retries and exponential backoff.\n\t *\n\t * @param downloadFileParams - Parameters for Lokalise API file download.\n\t * @returns The downloaded bundle metadata.\n\t * @throws {LokaliseError} If retries are exhausted or an API error occurs.\n\t */\n\tprotected async getTranslationsBundle(\n\t\tdownloadFileParams: DownloadFileParams,\n\t): Promise<DownloadBundle> {\n\t\treturn this.withExponentialBackoff(() =>\n\t\t\tthis.apiClient.files().download(this.projectId, downloadFileParams),\n\t\t);\n\t}\n\n\t/**\n\t * Retrieves a translation bundle from Lokalise with retries and exponential backoff.\n\t *\n\t * @param downloadFileParams - Parameters for Lokalise API file download.\n\t * @returns The queued process.\n\t * @throws {LokaliseError} If retries are exhausted or an API error occurs.\n\t */\n\tprotected async getTranslationsBundleAsync(\n\t\tdownloadFileParams: DownloadFileParams,\n\t): Promise<QueuedProcess> {\n\t\treturn this.withExponentialBackoff(() =>\n\t\t\tthis.apiClient.files().async_download(this.projectId, downloadFileParams),\n\t\t);\n\t}\n\n\t/**\n\t * Extracts a single entry from a ZIP archive to the specified output directory.\n\t *\n\t * Creates necessary directories and streams the file content to disk.\n\t *\n\t * @param entry - The ZIP entry to extract.\n\t * @param zipfile - The open ZIP file instance.\n\t * @param outputDir - The directory where the entry should be written.\n\t * @returns A promise that resolves when the entry is fully written.\n\t */\n\tprivate async handleZipEntry(\n\t\tentry: yauzl.Entry,\n\t\tzipfile: yauzl.ZipFile,\n\t\toutputDir: string,\n\t): Promise<void> {\n\t\tconst fullPath = this.processZipEntryPath(outputDir, entry.fileName);\n\n\t\tif (entry.fileName.endsWith(\"/\")) {\n\t\t\t// it's a directory\n\t\t\tawait this.createDir(fullPath);\n\t\t\treturn;\n\t\t}\n\n\t\tawait this.createDir(path.dirname(fullPath));\n\n\t\treturn new Promise((response, reject) => {\n\t\t\tzipfile.openReadStream(entry, (readErr, readStream) => {\n\t\t\t\tif (readErr || !readStream) {\n\t\t\t\t\treturn reject(\n\t\t\t\t\t\tnew LokaliseError(`Failed to read ZIP entry: ${entry.fileName}`),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst writeStream = fs.createWriteStream(fullPath);\n\t\t\t\treadStream.pipe(writeStream);\n\t\t\t\twriteStream.on(\"finish\", response);\n\t\t\t\twriteStream.on(\"error\", reject);\n\t\t\t\treadStream.on(\"error\", reject);\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Creates a directory and all necessary parent directories.\n\t *\n\t * @param dir - The directory path to create.\n\t * @returns A promise that resolves when the directory is created.\n\t */\n\tprivate async createDir(dir: string): Promise<void> {\n\t\tawait fs.promises.mkdir(dir, { recursive: true });\n\t}\n\n\t/**\n\t * Resolves and validates the full output path for a ZIP entry.\n\t *\n\t * Prevents path traversal attacks by ensuring the resolved path stays within the output directory.\n\t *\n\t * @param outputDir - The base output directory.\n\t * @param entryFilename - The filename of the ZIP entry.\n\t * @returns The absolute and safe path to write the entry.\n\t * @throws {LokaliseError} If the entry path is detected as malicious.\n\t */\n\tprivate processZipEntryPath(\n\t\toutputDir: string,\n\t\tentryFilename: string,\n\t): string {\n\t\t// Validate paths to avoid path traversal issues\n\t\tconst fullPath = path.resolve(outputDir, entryFilename);\n\t\tconst relative = path.relative(outputDir, fullPath);\n\t\tif (relative.startsWith(\"..\") || path.isAbsolute(relative)) {\n\t\t\tthrow new LokaliseError(`Malicious ZIP entry detected: ${entryFilename}`);\n\t\t}\n\n\t\treturn fullPath;\n\t}\n\n\t/**\n\t * Parses and validates a URL string, ensuring it uses HTTP or HTTPS protocol.\n\t *\n\t * @param value - The URL string to validate.\n\t * @returns A parsed `URL` object if valid.\n\t * @throws {LokaliseError} If the URL is invalid or uses an unsupported protocol.\n\t */\n\tprivate assertHttpUrl(value: string): URL {\n\t\tlet parsed: URL;\n\t\ttry {\n\t\t\tparsed = new URL(value);\n\t\t} catch {\n\t\t\tthrow new LokaliseError(`Invalid URL: ${value}`);\n\t\t}\n\n\t\tif (parsed.protocol !== \"http:\" && parsed.protocol !== \"https:\") {\n\t\t\tthrow new LokaliseError(`Unsupported protocol in URL: ${value}`);\n\t\t}\n\n\t\treturn parsed;\n\t}\n}\n","import type { ClientParams, QueuedProcess } from \"@lokalise/node-api\";\nimport {\n\tLokaliseApi,\n\tApiError as LokaliseApiError,\n\tLokaliseApiOAuth,\n} from \"@lokalise/node-api\";\nimport {\n\ttype LogFunction,\n\ttype LogLevel,\n\ttype LogThreshold,\n\tlogWithColor,\n\tlogWithLevel,\n} from \"kliedz\";\nimport { LokaliseError } from \"../errors/LokaliseError.js\";\nimport type {\n\tLokaliseExchangeConfig,\n\tRetryParams,\n} from \"../interfaces/index.js\";\n\n/**\n * A utility class for exchanging files with the Lokalise API.\n */\nexport class LokaliseFileExchange {\n\t/**\n\t * The Lokalise API client instance.\n\t */\n\tprotected readonly apiClient: LokaliseApi;\n\n\t/**\n\t * The ID of the project in Lokalise.\n\t */\n\tprotected readonly projectId: string;\n\n\t/**\n\t * Retry parameters for API requests.\n\t */\n\tprotected readonly retryParams: RetryParams;\n\n\t/**\n\t * Logger function.\n\t */\n\tprotected readonly logger: LogFunction;\n\n\t/**\n\t * Log threshold (do not print messages with severity less than the specified value).\n\t */\n\tprotected readonly logThreshold: LogThreshold;\n\n\t/**\n\t * Default retry parameters for API requests.\n\t */\n\tprivate static readonly defaultRetryParams: Required<RetryParams> = {\n\t\tmaxRetries: 3,\n\t\tinitialSleepTime: 1000,\n\t\tjitterRatio: 0.2,\n\t\trng: Math.random,\n\t};\n\n\tprivate static readonly FINISHED_STATUSES = [\n\t\t\"finished\",\n\t\t\"cancelled\",\n\t\t\"failed\",\n\t] as const;\n\n\tprivate static readonly RETRYABLE_CODES = [408, 429];\n\n\tprotected static readonly maxConcurrentProcesses = 6;\n\n\tprivate static isPendingStatus(status?: string | null): boolean {\n\t\treturn !LokaliseFileExchange.isFinishedStatus(status);\n\t}\n\n\tpublic static isFinishedStatus(status?: string | null): boolean {\n\t\treturn (\n\t\t\tstatus != null &&\n\t\t\t(LokaliseFileExchange.FINISHED_STATUSES as readonly string[]).includes(\n\t\t\t\tstatus,\n\t\t\t)\n\t\t);\n\t}\n\n\t/**\n\t * Creates a new instance of LokaliseFileExchange.\n\t *\n\t * @param clientConfig - Configuration for the Lokalise SDK.\n\t * @param exchangeConfig - The configuration object for file exchange operations.\n\t * @throws {LokaliseError} If the provided configuration is invalid.\n\t */\n\tconstructor(\n\t\tclientConfig: ClientParams,\n\t\t{\n\t\t\tprojectId,\n\t\t\tuseOAuth2 = false,\n\t\t\tretryParams,\n\t\t\tlogThreshold = \"info\",\n\t\t\tlogColor = true,\n\t\t}: LokaliseExchangeConfig,\n\t) {\n\t\tif (logColor) {\n\t\t\tthis.logger = logWithColor;\n\t\t} else {\n\t\t\tthis.logger = logWithLevel;\n\t\t}\n\n\t\tthis.logThreshold = logThreshold;\n\n\t\tlet lokaliseApiConfig = clientConfig;\n\n\t\tif (logThreshold === \"silent\") {\n\t\t\tlokaliseApiConfig = {\n\t\t\t\tsilent: true,\n\t\t\t\t...lokaliseApiConfig,\n\t\t\t};\n\t\t}\n\n\t\tif (useOAuth2) {\n\t\t\tthis.logMsg(\"debug\", \"Using OAuth 2 Lokalise API client\");\n\t\t\tthis.apiClient = new LokaliseApiOAuth(lokaliseApiConfig);\n\t\t} else {\n\t\t\tthis.logMsg(\"debug\", \"Using regular (token-based) Lokalise API client\");\n\t\t\tthis.apiClient = new LokaliseApi(lokaliseApiConfig);\n\t\t}\n\n\t\tthis.projectId = projectId;\n\n\t\tthis.retryParams = {\n\t\t\t...LokaliseFileExchange.defaultRetryParams,\n\t\t\t...retryParams,\n\t\t};\n\n\t\tthis.validateParams();\n\t}\n\n\t/**\n\t * Executes an asynchronous operation with exponential backoff retry logic.\n\t */\n\tprotected async withExponentialBackoff<T>(\n\t\toperation: () => Promise<T>,\n\t): Promise<T> {\n\t\tconst { maxRetries, initialSleepTime, jitterRatio, rng } = this.retryParams;\n\t\tthis.logMsg(\n\t\t\t\"debug\",\n\t\t\t`Running operation with exponential backoff; max retries: ${maxRetries}`,\n\t\t);\n\n\t\tfor (let attempt = 1; attempt <= maxRetries + 1; attempt++) {\n\t\t\ttry {\n\t\t\t\tthis.logMsg(\"debug\", `Attempt #${attempt}...`);\n\t\t\t\treturn await operation();\n\t\t\t} catch (error: unknown) {\n\t\t\t\tif (error instanceof LokaliseApiError && this.isRetryable(error)) {\n\t\t\t\t\tthis.logMsg(\"debug\", `Retryable error caught: ${error.message}`);\n\n\t\t\t\t\tif (attempt === maxRetries + 1) {\n\t\t\t\t\t\tthrow new LokaliseError(\n\t\t\t\t\t\t\t`Maximum retries reached: ${error.message ?? \"Unknown error\"}`,\n\t\t\t\t\t\t\terror.code,\n\t\t\t\t\t\t\terror.details,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst base = initialSleepTime * 2 ** (attempt - 1);\n\t\t\t\t\tconst maxJitter = Math.floor(base * jitterRatio);\n\t\t\t\t\tconst jitter = maxJitter > 0 ? Math.floor(rng() * maxJitter) : 0;\n\t\t\t\t\tconst sleepMs = base + jitter;\n\n\t\t\t\t\tthis.logMsg(\"debug\", `Waiting ${sleepMs}ms before retry...`);\n\t\t\t\t\tawait LokaliseFileExchange.sleep(sleepMs);\n\t\t\t\t} else if (error instanceof LokaliseApiError) {\n\t\t\t\t\tthrow new LokaliseError(error.message, error.code, error.details);\n\t\t\t\t} else {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// This line is unreachable but keeps TS happy.\n\t\tthrow new LokaliseError(\"Unexpected error during operation.\", 500);\n\t}\n\n\t/**\n\t * Polls the status of queued processes until they are marked as \"finished\" or until the maximum wait time is exceeded.\n\t */\n\tprotected async pollProcesses(\n\t\tprocesses: QueuedProcess[],\n\t\tinitialWaitTime: number,\n\t\tmaxWaitTime: number,\n\t\tconcurrency = LokaliseFileExchange.maxConcurrentProcesses,\n\t): Promise<QueuedProcess[]> {\n\t\tthis.logMsg(\n\t\t\t\"debug\",\n\t\t\t`Start polling processes. Total processes count: ${processes.length}`,\n\t\t);\n\n\t\tconst startTime = Date.now();\n\t\tlet waitTime = initialWaitTime;\n\n\t\tconst processMap = new Map<string, QueuedProcess>();\n\t\tconst pendingProcessIds = new Set<string>();\n\n\t\tthis.logMsg(\"debug\", \"Initial processes check...\");\n\n\t\tfor (const p of processes) {\n\t\t\tif (p.status) {\n\t\t\t\tthis.logMsg(\n\t\t\t\t\t\"debug\",\n\t\t\t\t\t`Process ID: ${p.process_id}, status: ${p.status}`,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthis.logMsg(\"debug\", `Process ID: ${p.process_id}, status is missing`);\n\t\t\t}\n\n\t\t\tprocessMap.set(p.process_id, p);\n\n\t\t\tif (LokaliseFileExchange.isPendingStatus(p.status)) {\n\t\t\t\tpendingProcessIds.add(p.process_id);\n\t\t\t}\n\t\t}\n\n\t\tlet didFastFollow = false;\n\n\t\twhile (pendingProcessIds.size > 0 && Date.now() - startTime < maxWaitTime) {\n\t\t\tthis.logMsg(\"debug\", `Polling... Pending IDs: ${pendingProcessIds.size}`);\n\n\t\t\tif (\n\t\t\t\t!didFastFollow &&\n\t\t\t\t[...processMap.values()].some((p) => p.status == null)\n\t\t\t) {\n\t\t\t\tthis.logMsg(\n\t\t\t\t\t\"debug\",\n\t\t\t\t\t\"Fast-follow: some statuses missing, quick recheck in 200ms\",\n\t\t\t\t);\n\t\t\t\tawait LokaliseFileExchange.sleep(200);\n\t\t\t\tdidFastFollow = true;\n\t\t\t}\n\n\t\t\tconst ids = [...pendingProcessIds];\n\t\t\tconst batch = await this.fetchProcessesBatch(ids, concurrency);\n\n\t\t\tfor (const { id, process } of batch) {\n\t\t\t\tif (!process) continue;\n\t\t\t\tprocessMap.set(id, process);\n\n\t\t\t\tif (LokaliseFileExchange.isFinishedStatus(process.status)) {\n\t\t\t\t\tthis.logMsg(\n\t\t\t\t\t\t\"debug\",\n\t\t\t\t\t\t`Process ${id} completed with status=${process.status}.`,\n\t\t\t\t\t);\n\t\t\t\t\tpendingProcessIds.delete(id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (pendingProcessIds.size === 0) {\n\t\t\t\tthis.logMsg(\"debug\", \"Finished polling. Pending processes IDs: 0\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst elapsed = Date.now() - startTime;\n\t\t\tconst remaining = maxWaitTime - elapsed;\n\n\t\t\tif (remaining <= 0) {\n\t\t\t\tthis.logMsg(\n\t\t\t\t\t\"debug\",\n\t\t\t\t\t\"Time budget exhausted, stopping polling without extra sleep.\",\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst sleepMs = Math.min(waitTime, remaining);\n\t\t\tthis.logMsg(\"debug\", `Waiting ${sleepMs}...`);\n\t\t\tawait LokaliseFileExchange.sleep(sleepMs);\n\n\t\t\twaitTime = Math.min(\n\t\t\t\twaitTime * 2,\n\t\t\t\tMath.max(0, maxWaitTime - (Date.now() - startTime)),\n\t\t\t);\n\t\t}\n\n\t\tif (pendingProcessIds.size > 0) {\n\t\t\tthis.logMsg(\n\t\t\t\t\"debug\",\n\t\t\t\t`Final refresh for ${pendingProcessIds.size} pending processes before return...`,\n\t\t\t);\n\n\t\t\tconst finalBatch = await this.fetchProcessesBatch(\n\t\t\t\t[...pendingProcessIds],\n\t\t\t\tconcurrency,\n\t\t\t);\n\n\t\t\tfor (const { id, process } of finalBatch) {\n\t\t\t\tif (process) processMap.set(id, process);\n\t\t\t}\n\t\t}\n\n\t\treturn Array.from(processMap.values());\n\t}\n\n\t/**\n\t * Determines if a given error is eligible for retry.\n\t */\n\tprivate isRetryable(error: LokaliseApiError): boolean {\n\t\treturn LokaliseFileExchange.RETRYABLE_CODES.includes(error.code);\n\t}\n\n\t/**\n\t * Logs a message with a specified level and the current threshold.\n\t */\n\tprotected logMsg(level: LogLevel, ...args: unknown[]): void {\n\t\tthis.logger(\n\t\t\t{ level, threshold: this.logThreshold, withTimestamp: true },\n\t\t\t...args,\n\t\t);\n\t}\n\n\t/**\n\t * Retrieves the latest state of a queued process from the API.\n\t */\n\tprotected async getUpdatedProcess(processId: string): Promise<QueuedProcess> {\n\t\tthis.logMsg(\"debug\", `Requesting update for process ID: ${processId}`);\n\n\t\tconst updatedProcess = await this.apiClient\n\t\t\t.queuedProcesses()\n\t\t\t.get(processId, { project_id: this.projectId });\n\n\t\tif (updatedProcess.status) {\n\t\t\tthis.logMsg(\n\t\t\t\t\"debug\",\n\t\t\t\t`Process ID: ${updatedProcess.process_id}, status: ${updatedProcess.status}`,\n\t\t\t);\n\t\t} else {\n\t\t\tthis.logMsg(\n\t\t\t\t\"debug\",\n\t\t\t\t`Process ID: ${updatedProcess.process_id}, status is missing`,\n\t\t\t);\n\t\t}\n\n\t\treturn updatedProcess;\n\t}\n\n\t/**\n\t * Validates the required client configuration parameters.\n\t */\n\tprivate validateParams(): void {\n\t\tif (!this.projectId || typeof this.projectId !== \"string\") {\n\t\t\tthrow new LokaliseError(\"Invalid or missing Project ID.\");\n\t\t}\n\n\t\tconst { maxRetries, initialSleepTime, jitterRatio } = this.retryParams;\n\n\t\tif (maxRetries < 0) {\n\t\t\tthrow new LokaliseError(\n\t\t\t\t\"maxRetries must be greater than or equal to zero.\",\n\t\t\t);\n\t\t}\n\t\tif (initialSleepTime <= 0) {\n\t\t\tthrow new LokaliseError(\"initialSleepTime must be a positive value.\");\n\t\t}\n\t\tif (jitterRatio < 0 || jitterRatio > 1)\n\t\t\tthrow new LokaliseError(\"jitterRatio must be between 0 and 1.\");\n\t}\n\n\tprotected async runWithConcurrencyLimit<T, R>(\n\t\titems: T[],\n\t\tlimit: number,\n\t\tworker: (item: T, index: number) => Promise<R>,\n\t): Promise<R[]> {\n\t\tconst results = new Array<R>(items.length);\n\t\tlet i = 0;\n\n\t\tconst workers = new Array(Math.min(limit, items.length))\n\t\t\t.fill(null)\n\t\t\t.map(async () => {\n\t\t\t\twhile (true) {\n\t\t\t\t\tconst idx = i++;\n\t\t\t\t\tif (idx >= items.length) break;\n\t\t\t\t\tconst item = items[idx];\n\t\t\t\t\tif (item === undefined) {\n\t\t\t\t\t\tthrow new Error(`Missing item at index ${idx}`);\n\t\t\t\t\t}\n\n\t\t\t\t\tresults[idx] = await worker(item, idx);\n\t\t\t\t}\n\t\t\t});\n\n\t\tawait Promise.all(workers);\n\t\treturn results;\n\t}\n\n\tprotected async fetchProcessesBatch(\n\t\tprocessIds: string[],\n\t\tconcurrency = LokaliseFileExchange.maxConcurrentProcesses,\n\t): Promise<Array<{ id: string; process?: QueuedProcess }>> {\n\t\treturn this.runWithConcurrencyLimit(processIds, concurrency, async (id) => {\n\t\t\ttry {\n\t\t\t\tconst updated = await this.getUpdatedProcess(id);\n\t\t\t\treturn { id, process: updated };\n\t\t\t} catch (error) {\n\t\t\t\tthis.logMsg(\"warn\", `Failed to fetch process ${id}:`, error);\n\t\t\t\treturn { id };\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Pauses execution for the specified number of milliseconds.\n\t */\n\tprotected static sleep(ms: number): Promise<void> {\n\t\treturn new Promise((resolve) => setTimeout(resolve, ms));\n\t}\n}\n","import fs from \"node:fs\";\nimport path from \"node:path\";\nimport type { QueuedProcess, UploadFileParams } from \"@lokalise/node-api\";\nimport type {\n\tCollectFileParams,\n\tFileUploadError,\n\tPartialUploadFileParams,\n\tProcessedFile,\n\tProcessUploadFileParams,\n\tQueuedUploadProcessesWithErrors,\n\tUploadTranslationParams,\n} from \"../interfaces/index.js\";\nimport { LokaliseFileExchange } from \"./LokaliseFileExchange.js\";\n\n/**\n * Handles uploading translation files to Lokalise.\n */\nexport class LokaliseUpload extends LokaliseFileExchange {\n\tprivate static readonly defaultPollingParams = {\n\t\tpollStatuses: false,\n\t\tpollInitialWaitTime: 1000,\n\t\tpollMaximumWaitTime: 120_000,\n\t};\n\n\t/**\n\t * Collects files, uploads them to Lokalise, and optionally polls for process completion, returning both processes and errors.\n\t *\n\t * @param {UploadTranslationParams} uploadTranslationParams - Parameters for collecting and uploading files.\n\t * @returns {Promise<{ processes: QueuedProcess[]; errors: FileUploadError[] }>} A promise resolving with successful processes and upload errors.\n\t */\n\tasync uploadTranslations({\n\t\tuploadFileParams,\n\t\tcollectFileParams,\n\t\tprocessUploadFileParams,\n\t}: UploadTranslationParams = {}): Promise<QueuedUploadProcessesWithErrors> {\n\t\tthis.logMsg(\"debug\", \"Uploading translations to Lokalise...\");\n\n\t\tconst { pollStatuses, pollInitialWaitTime, pollMaximumWaitTime } = {\n\t\t\t...LokaliseUpload.defaultPollingParams,\n\t\t\t...processUploadFileParams,\n\t\t};\n\n\t\tthis.logMsg(\"debug\", \"Collecting files to upload...\");\n\t\tconst collectedFiles = await this.collectFiles(collectFileParams);\n\t\tthis.logMsg(\"debug\", \"Collected files:\", collectedFiles);\n\n\t\tthis.logMsg(\"debug\", \"Performing parallel upload...\");\n\t\tconst { processes, errors } = await this.parallelUpload(\n\t\t\tcollectedFiles,\n\t\t\tuploadFileParams,\n\t\t\tprocessUploadFileParams,\n\t\t);\n\n\t\tlet completedProcesses = processes;\n\t\tthis.logMsg(\n\t\t\t\"debug\",\n\t\t\t\"File uploading queued! IDs:\",\n\t\t\tcompletedProcesses.map((p) => p.process_id),\n\t\t);\n\n\t\tif (pollStatuses) {\n\t\t\tthis.logMsg(\"debug\", \"Polling queued processes...\");\n\n\t\t\tcompletedProcesses = await this.pollProcesses(\n\t\t\t\tprocesses,\n\t\t\t\tpollInitialWaitTime,\n\t\t\t\tpollMaximumWaitTime,\n\t\t\t);\n\n\t\t\tthis.logMsg(\"debug\", \"Polling completed!\");\n\t\t}\n\n\t\tthis.logMsg(\"debug\", \"Upload successful!\");\n\n\t\treturn { processes: completedProcesses, errors };\n\t}\n\n\t/**\n\t * Collects files from the filesystem based on the given parameters.\n\t *\n\t * @param {CollectFileParams} collectFileParams - Parameters for file collection, including directories, extensions, and patterns.\n\t * @returns {Promise<string[]>} A promise resolving with the list of collected file paths.\n\t */\n\tprotected async collectFiles({\n\t\tinputDirs = [\"./locales\"],\n\t\textensions = [\".*\"],\n\t\texcludePatterns = [],\n\t\trecursive = true,\n\t\tfileNamePattern = \".*\",\n\t}: CollectFileParams = {}): Promise<string[]> {\n\t\tconst queue = this.makeQueue(inputDirs);\n\t\tconst normalizedExtensions = this.normalizeExtensions(extensions);\n\t\tconst fileNameRegex = this.makeFilenameRegexp(fileNamePattern);\n\t\tconst excludeRegexes = this.makeExcludeRegExes(excludePatterns);\n\n\t\tconst files = await this.processCollectionQueue(\n\t\t\tqueue,\n\t\t\tnormalizedExtensions,\n\t\t\tfileNameRegex,\n\t\t\texcludeRegexes,\n\t\t\trecursive,\n\t\t);\n\n\t\treturn files.sort();\n\t}\n\n\t/**\n\t * Uploads a single file to Lokalise.\n\t *\n\t * @param {UploadFileParams} uploadParams - Parameters for uploading the file.\n\t * @returns {Promise<QueuedProcess>} A promise resolving with the upload process details.\n\t */\n\tprotected async uploadSingleFile(\n\t\tuploadParams: UploadFileParams,\n\t): Promise<QueuedProcess> {\n\t\treturn this.withExponentialBackoff(() =>\n\t\t\tthis.apiClient.files().upload(this.projectId, uploadParams),\n\t\t);\n\t}\n\n\t/**\n\t * Processes a file to prepare it for upload, converting it to base64 and extracting its language code.\n\t *\n\t * @param {string} file - The absolute path to the file.\n\t * @param {string} projectRoot - The root directory of the project.\n\t * @param {ProcessUploadFileParams} [processParams] - Optional processing settings including inferers.\n\t * @returns {Promise<ProcessedFile>} A promise resolving with the processed file details, including base64 content, relative path, and language code.\n\t */\n\tprotected async processFile(\n\t\tfile: string,\n\t\tprojectRoot: string,\n\t\tprocessParams?: ProcessUploadFileParams,\n\t): Promise<ProcessedFile> {\n\t\tlet relativePath: string;\n\t\ttry {\n\t\t\trelativePath = processParams?.filenameInferer\n\t\t\t\t? await processParams.filenameInferer(file)\n\t\t\t\t: \"\";\n\t\t\tif (!relativePath.trim()) {\n\t\t\t\tthrow new Error(\"Invalid filename: empty or only whitespace\");\n\t\t\t}\n\t\t} catch {\n\t\t\trelativePath = path.posix.relative(\n\t\t\t\tthis.toPosixPath(projectRoot),\n\t\t\t\tthis.toPosixPath(file),\n\t\t\t);\n\t\t}\n\n\t\tlet languageCode: string;\n\t\ttry {\n\t\t\tlanguageCode = processParams?.languageInferer\n\t\t\t\t? await processParams.languageInferer(file)\n\t\t\t\t: \"\";\n\t\t\tif (!languageCode.trim()) {\n\t\t\t\tthrow new Error(\"Invalid language code: empty or only whitespace\");\n\t\t\t}\n\t\t} catch {\n\t\t\tconst baseName = path.basename(relativePath);\n\t\t\tlanguageCode = baseName.split(\".\").slice(-2, -1)[0] ?? \"unknown\";\n\t\t}\n\n\t\tconst fileContent = await fs.promises.readFile(file);\n\n\t\treturn {\n\t\t\tdata: fileContent.toString(\"base64\"),\n\t\t\tfilename: relativePath,\n\t\t\tlang_iso: languageCode,\n\t\t};\n\t}\n\n\t/**\n\t * Uploads files in parallel with a limit on the number of concurrent uploads.\n\t *\n\t * @param {string[]} files - List of file paths to upload.\n\t * @param {Partial<UploadFileParams>} baseUploadFileParams - Base parameters for uploads.\n\t * @param {ProcessUploadFileParams} [processParams] - Optional processing settings including inferers.\n\t * @returns {Promise<{ processes: QueuedProcess[]; errors: FileUploadError[] }>} A promise resolving with successful processes and upload errors.\n\t */\n\tprivate async parallelUpload(\n\t\tfiles: string[],\n\t\tbaseUploadFileParams: PartialUploadFileParams = {},\n\t\tprocessParams?: ProcessUploadFileParams,\n\t): Promise<QueuedUploadProcessesWithErrors> {\n\t\tconst projectRoot = process.cwd();\n\t\tconst queuedProcesses: QueuedProcess[] = [];\n\t\tconst errors: FileUploadError[] = [];\n\n\t\tawait this.runWithConcurrencyLimit(\n\t\t\tfiles,\n\t\t\tLokaliseUpload.maxConcurrentProcesses,\n\t\t\tasync (file) => {\n\t\t\t\ttry {\n\t\t\t\t\tconst processedFileParams = await this.processFile(\n\t\t\t\t\t\tfile,\n\t\t\t\t\t\tprojectRoot,\n\t\t\t\t\t\tprocessParams,\n\t\t\t\t\t);\n\t\t\t\t\tconst queued = await this.uploadSingleFile({\n\t\t\t\t\t\t...baseUploadFileParams,\n\t\t\t\t\t\t...processedFileParams,\n\t\t\t\t\t});\n\t\t\t\t\tqueuedProcesses.push(queued);\n\t\t\t\t} catch (error) {\n\t\t\t\t\terrors.push({ file, error });\n\t\t\t\t}\n\t\t\t},\n\t\t);\n\n\t\treturn { processes: queuedProcesses, errors };\n\t}\n\n\t/**\n\t * Normalizes an array of file extensions by ensuring each starts with a dot and is lowercase.\n\t *\n\t * @param extensions - The list of file extensions to normalize.\n\t * @returns A new array with normalized file extensions.\n\t */\n\tprivate normalizeExtensions(extensions: string[]): string[] {\n\t\treturn extensions.map((ext) =>\n\t\t\t(ext.startsWith(\".\") ? ext : `.${ext}`).toLowerCase(),\n\t\t);\n\t}\n\n\t/**\n\t * Determines whether a file should be collected based on its extension and name pattern.\n\t *\n\t * @param entry - The directory entry to evaluate.\n\t * @param normalizedExtensions - List of allowed file extensions.\n\t * @param fileNameRegex - Regular expression to match valid filenames.\n\t * @returns `true` if the file matches both extension and name pattern, otherwise `false`.\n\t */\n\tprivate shouldCollectFile(\n\t\tentry: fs.Dirent,\n\t\tnormalizedExtensions: string[],\n\t\tfileNameRegex: RegExp,\n\t): boolean {\n\t\tconst fileExt = path.extname(entry.name).toLowerCase();\n\t\tconst matchesExtension =\n\t\t\tnormalizedExtensions.includes(\".*\") ||\n\t\t\tnormalizedExtensions.includes(fileExt);\n\t\tconst matchesFilenamePattern = fileNameRegex.test(entry.name);\n\n\t\treturn matchesExtension && matchesFilenamePattern;\n\t}\n\n\t/**\n\t * Creates a regular expression from a given pattern string or RegExp.\n\t *\n\t * @param fileNamePattern - The filename pattern to convert into a RegExp.\n\t * @returns A valid RegExp object.\n\t * @throws {Error} If the pattern string is invalid and cannot be compiled.\n\t */\n\tprivate makeFilenameRegexp(fileNamePattern: string | RegExp): RegExp {\n\t\ttry {\n\t\t\treturn new RegExp(fileNamePattern);\n\t\t} catch {\n\t\t\tthrow new Error(`Invalid fileNamePattern: ${fileNamePattern}`);\n\t\t}\n\t}\n\n\t/**\n\t * Converts an array of exclude patterns into an array of RegExp objects.\n\t *\n\t * @param excludePatterns - An array of strings or regular expressions to exclude.\n\t * @returns An array of compiled RegExp objects.\n\t * @throws {Error} If any pattern is invalid and cannot be compiled.\n\t */\n\tprivate makeExcludeRegExes(excludePatterns: string[] | RegExp[]): RegExp[] {\n\t\tif (excludePatterns.length === 0) {\n\t\t\treturn [];\n\t\t}\n\t\ttry {\n\t\t\treturn excludePatterns.map((pattern) => new RegExp(pattern));\n\t\t} catch (err) {\n\t\t\tconst msg = err instanceof Error ? err.message : String(err);\n\t\t\tthrow new Error(`Invalid excludePatterns: ${msg}`);\n\t\t}\n\t}\n\n\t/**\n\t * Safely reads the contents of a directory, returning an empty array if access fails.\n\t *\n\t * Logs a warning if the directory cannot be read (e.g. due to permissions or non-existence).\n\t *\n\t * @param dir - The directory path to read.\n\t * @returns A promise that resolves to an array of directory entries, or an empty array on failure.\n\t */\n\tprivate async safeReadDir(dir: string): Promise<fs.Dirent[]> {\n\t\ttry {\n\t\t\treturn await fs.promises.readdir(dir, { withFileTypes: true });\n\t\t} catch {\n\t\t\tthis.logMsg(\"warn\", `Skipping inaccessible directory: ${dir}...`);\n\t\t\treturn [];\n\t\t}\n\t}\n\n\t/**\n\t * Checks if a file path matches any of the provided exclusion patterns.\n\t *\n\t * @param filePath - The path of the file to check.\n\t * @param excludeRegexes - An array of RegExp patterns to test against.\n\t * @returns `true` if the file path matches any exclude pattern, otherwise `false`.\n\t */\n\tprivate shouldExclude(filePath: string, rx: RegExp[]): boolean {\n\t\tconst posix = this.toPosixPath(filePath);\n\t\treturn rx.some((r) => r.test(filePath) || r.test(posix));\n\t}\n\n\t/**\n\t * Creates a queue of absolute paths from the provided input directories.\n\t *\n\t * @param inputDirs - An array of input directory paths (relative or absolute).\n\t * @returns An array of resolved absolute directory paths.\n\t */\n\tprivate makeQueue(inputDirs: string[]): string[] {\n\t\treturn [...inputDirs.map((dir) => path.resolve(dir))];\n\t}\n\n\t/**\n\t * Processes a queue of directories to collect files matching given criteria.\n\t *\n\t * Recursively reads directories (if enabled), filters files by extension,\n\t * filename pattern, and exclusion rules, and collects matching file paths.\n\t *\n\t * @param queue - The list of directories to process.\n\t * @param exts - Allowed file extensions (normalized).\n\t * @param nameRx - Regular expression to match valid filenames.\n\t * @param excludeRx - Array of exclusion patterns.\n\t * @param recursive - Whether to traverse subdirectories.\n\t * @returns A promise that resolves to an array of matched file paths.\n\t */\n\tprivate async processCollectionQueue(\n\t\tqueue: string[],\n\t\texts: string[],\n\t\tnameRx: RegExp,\n\t\texcludeRx: RegExp[],\n\t\trecursive: boolean,\n\t): Promise<string[]> {\n\t\tconst found: string[] = [];\n\n\t\twhile (queue.length) {\n\t\t\tconst dir = queue.shift();\n\t\t\tif (!dir) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst entries = await this.safeReadDir(dir);\n\t\t\tfor (const entry of entries) {\n\t\t\t\tconst fullPath = path.resolve(dir, entry.name);\n\t\t\t\tthis.handleEntry(entry, fullPath, queue, found, {\n\t\t\t\t\texts,\n\t\t\t\t\tnameRx,\n\t\t\t\t\texcludeRx,\n\t\t\t\t\trecursive,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn found;\n\t}\n\n\t/**\n\t * Handles a single directory entry during file collection.\n\t *\n\t * Applies exclusion rules, optionally queues directories for recursion,\n\t * and collects files that match the specified extension and filename pattern.\n\t *\n\t * @param entry - The directory entry to handle.\n\t * @param fullPath - The absolute path to the entry.\n\t * @param queue - The processing queue for directories.\n\t * @param found - The list to store matched file paths.\n\t * @param opts - Options including extensions, name pattern, exclusions, and recursion flag.\n\t */\n\tprivate handleEntry(\n\t\tentry: fs.Dirent,\n\t\tfullPath: string,\n\t\tqueue: string[],\n\t\tfound: string[],\n\t\topts: {\n\t\t\texts: string[];\n\t\t\tnameRx: RegExp;\n\t\t\texcludeRx: RegExp[];\n\t\t\trecursive: boolean;\n\t\t},\n\t): void {\n\t\tif (this.shouldExclude(fullPath, opts.excludeRx)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (entry.isDirectory()) {\n\t\t\tif (opts.recursive) {\n\t\t\t\tqueue.push(fullPath);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (\n\t\t\tentry.isFile() &&\n\t\t\tthis.shouldCollectFile(entry, opts.exts, opts.nameRx)\n\t\t) {\n\t\t\tfound.push(fullPath);\n\t\t}\n\t}\n\n\tprivate toPosixPath(p: string): string {\n\t\treturn p.split(path.sep).join(path.posix.sep);\n\t}\n}\n"],"mappings":"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","names":["process","fs","path","path","fs"]}
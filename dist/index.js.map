{"version":3,"sources":["../lib/services/LokaliseDownload.ts","../lib/errors/LokaliseError.ts","../lib/services/LokaliseFileExchange.ts","../lib/services/LokaliseUpload.ts"],"sourcesContent":["import fs from \"node:fs\";\nimport os from \"node:os\";\nimport path from \"node:path\";\nimport { pipeline } from \"node:stream\";\nimport { promisify } from \"node:util\";\nimport type {\n\tDownloadBundle,\n\tDownloadFileParams,\n\tDownloadedFileProcessDetails,\n\tQueuedProcess,\n} from \"@lokalise/node-api\";\nimport yauzl from \"yauzl\";\nimport { LokaliseError } from \"../errors/LokaliseError.js\";\nimport type { DownloadTranslationParams } from \"../interfaces/index.js\";\nimport { LokaliseFileExchange } from \"./LokaliseFileExchange.js\";\n\n/**\n * Handles downloading and extracting translation files from Lokalise.\n */\nexport class LokaliseDownload extends LokaliseFileExchange {\n\tprivate static readonly defaultProcessParams = {\n\t\tasyncDownload: false,\n\t\tpollInitialWaitTime: 1000,\n\t\tpollMaximumWaitTime: 120_000,\n\t\tbundleDownloadTimeout: 0,\n\t};\n\n\tprivate readonly streamPipeline = promisify(pipeline);\n\n\t/**\n\t * Downloads translations from Lokalise, optionally using async polling, and extracts them to disk.\n\t *\n\t * @param downloadTranslationParams - Full configuration for the download process, extraction destination, and optional polling or timeout settings.\n\t * @throws {LokaliseError} If the download, polling, or extraction fails.\n\t */\n\tasync downloadTranslations({\n\t\tdownloadFileParams,\n\t\textractParams = {},\n\t\tprocessDownloadFileParams,\n\t}: DownloadTranslationParams): Promise<void> {\n\t\tthis.logMsg(\"debug\", \"Downloading translations from Lokalise...\");\n\n\t\tconst {\n\t\t\tasyncDownload,\n\t\t\tpollInitialWaitTime,\n\t\t\tpollMaximumWaitTime,\n\t\t\tbundleDownloadTimeout,\n\t\t} = {\n\t\t\t...LokaliseDownload.defaultProcessParams,\n\t\t\t...processDownloadFileParams,\n\t\t};\n\n\t\tlet translationsBundleURL: string;\n\n\t\tif (asyncDownload) {\n\t\t\tthis.logMsg(\"debug\", \"Async download mode enabled.\");\n\n\t\t\tconst downloadProcess =\n\t\t\t\tawait this.getTranslationsBundleAsync(downloadFileParams);\n\n\t\t\tthis.logMsg(\n\t\t\t\t\"debug\",\n\t\t\t\t`Waiting for download process ID ${downloadProcess.process_id} to complete...`,\n\t\t\t);\n\n\t\t\tconst completedProcess = (\n\t\t\t\tawait this.pollProcesses(\n\t\t\t\t\t[downloadProcess],\n\t\t\t\t\tpollInitialWaitTime,\n\t\t\t\t\tpollMaximumWaitTime,\n\t\t\t\t)\n\t\t\t)[0];\n\n\t\t\tthis.logMsg(\"debug\", `Download process status is ${completedProcess}`);\n\n\t\t\tif (completedProcess.status === \"finished\") {\n\t\t\t\tconst completedProcessDetails =\n\t\t\t\t\tcompletedProcess.details as DownloadedFileProcessDetails;\n\t\t\t\ttranslationsBundleURL = completedProcessDetails.download_url;\n\t\t\t} else {\n\t\t\t\tthrow new LokaliseError(\n\t\t\t\t\t`Download process took too long to finalize; gave up after ${pollMaximumWaitTime}ms`,\n\t\t\t\t\t500,\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.logMsg(\"debug\", \"Async download mode disabled.\");\n\n\t\t\tconst translationsBundle =\n\t\t\t\tawait this.getTranslationsBundle(downloadFileParams);\n\t\t\ttranslationsBundleURL = translationsBundle.bundle_url;\n\t\t}\n\n\t\tthis.logMsg(\n\t\t\t\"debug\",\n\t\t\t`Downloading translation bundle from ${translationsBundleURL}`,\n\t\t);\n\n\t\tconst zipFilePath = await this.downloadZip(\n\t\t\ttranslationsBundleURL,\n\t\t\tbundleDownloadTimeout,\n\t\t);\n\n\t\tconst unpackTo = path.resolve(extractParams.outputDir ?? \"./\");\n\n\t\tthis.logMsg(\n\t\t\t\"debug\",\n\t\t\t`Unpacking translations from ${zipFilePath} to ${unpackTo}`,\n\t\t);\n\n\t\ttry {\n\t\t\tawait this.unpackZip(zipFilePath, unpackTo);\n\n\t\t\tthis.logMsg(\"debug\", \"Translations unpacked!\");\n\t\t} finally {\n\t\t\tthis.logMsg(\"debug\", `Removing temp archive from ${zipFilePath}`);\n\t\t\tawait fs.promises.unlink(zipFilePath);\n\t\t}\n\t}\n\n\t/**\n\t * Unpacks a ZIP file into the specified directory.\n\t *\n\t * @param zipFilePath - Path to the ZIP file.\n\t * @param outputDir - Directory to extract the files into.\n\t * @throws {LokaliseError} If extraction fails or malicious paths are detected.\n\t */\n\tprotected async unpackZip(\n\t\tzipFilePath: string,\n\t\toutputDir: string,\n\t): Promise<void> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tyauzl.open(zipFilePath, { lazyEntries: true }, (err, zipfile) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn reject(\n\t\t\t\t\t\tnew LokaliseError(\n\t\t\t\t\t\t\t`Failed to open ZIP file at ${zipFilePath}: ${err.message}`,\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (!zipfile) {\n\t\t\t\t\treturn reject(\n\t\t\t\t\t\tnew LokaliseError(`ZIP file is invalid or empty: ${zipFilePath}`),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tzipfile.readEntry();\n\n\t\t\t\tzipfile.on(\"entry\", (entry) => {\n\t\t\t\t\tthis.handleZipEntry(entry, zipfile, outputDir)\n\t\t\t\t\t\t.then(() => zipfile.readEntry())\n\t\t\t\t\t\t.catch(reject);\n\t\t\t\t});\n\n\t\t\t\tzipfile.on(\"end\", resolve);\n\t\t\t\tzipfile.on(\"error\", reject);\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Downloads a ZIP file from the given URL.\n\t *\n\t * @param url - The URL of the ZIP file.\n\t * @returns The file path of the downloaded ZIP file.\n\t * @throws {LokaliseError} If the download fails or the response body is empty.\n\t */\n\tprotected async downloadZip(\n\t\turl: string,\n\t\tdownloadTimeout = 0,\n\t): Promise<string> {\n\t\tconst bundleURL = this.assertHttpUrl(url);\n\n\t\tconst uid = `${process.pid}-${Date.now()}-${Math.random().toString(16).slice(2)}`;\n\t\tconst tempZipPath = path.join(os.tmpdir(), `lokalise-${uid}.zip`);\n\t\tlet response: Response;\n\n\t\tconst signal =\n\t\t\tdownloadTimeout > 0 ? AbortSignal.timeout(downloadTimeout) : undefined;\n\n\t\ttry {\n\t\t\tresponse = await fetch(bundleURL, {\n\t\t\t\tsignal,\n\t\t\t});\n\t\t} catch (err) {\n\t\t\tif (err instanceof Error) {\n\t\t\t\tif (err.name === \"TimeoutError\") {\n\t\t\t\t\tthrow new LokaliseError(\n\t\t\t\t\t\t`Request timed out after ${downloadTimeout}ms`,\n\t\t\t\t\t\t408,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treason: \"timeout\",\n\t\t\t\t\t\t},\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tthrow new LokaliseError(err.message, 500, {\n\t\t\t\t\treason: \"network or fetch error\",\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthrow new LokaliseError(\"An unknown error occurred\", 500, {\n\t\t\t\treason: String(err),\n\t\t\t});\n\t\t}\n\n\t\tif (!response.ok) {\n\t\t\tthrow new LokaliseError(\n\t\t\t\t`Failed to download ZIP file: ${response.statusText} (${response.status})`,\n\t\t\t);\n\t\t}\n\n\t\tconst body = response.body;\n\t\tif (!body) {\n\t\t\tthrow new LokaliseError(\n\t\t\t\t`Response body is null. Cannot download ZIP file from URL: ${url}`,\n\t\t\t);\n\t\t}\n\n\t\tawait this.streamPipeline(body, fs.createWriteStream(tempZipPath));\n\t\treturn tempZipPath;\n\t}\n\n\t/**\n\t * Retrieves a translation bundle from Lokalise with retries and exponential backoff.\n\t *\n\t * @param downloadFileParams - Parameters for Lokalise API file download.\n\t * @returns The downloaded bundle metadata.\n\t * @throws {LokaliseError} If retries are exhausted or an API error occurs.\n\t */\n\tprotected async getTranslationsBundle(\n\t\tdownloadFileParams: DownloadFileParams,\n\t): Promise<DownloadBundle> {\n\t\treturn this.withExponentialBackoff(() =>\n\t\t\tthis.apiClient.files().download(this.projectId, downloadFileParams),\n\t\t);\n\t}\n\n\t/**\n\t * Retrieves a translation bundle from Lokalise with retries and exponential backoff.\n\t *\n\t * @param downloadFileParams - Parameters for Lokalise API file download.\n\t * @returns The queued process.\n\t * @throws {LokaliseError} If retries are exhausted or an API error occurs.\n\t */\n\tprotected async getTranslationsBundleAsync(\n\t\tdownloadFileParams: DownloadFileParams,\n\t): Promise<QueuedProcess> {\n\t\treturn this.withExponentialBackoff(() =>\n\t\t\tthis.apiClient.files().async_download(this.projectId, downloadFileParams),\n\t\t);\n\t}\n\n\t/**\n\t * Extracts a single entry from a ZIP archive to the specified output directory.\n\t *\n\t * Creates necessary directories and streams the file content to disk.\n\t *\n\t * @param entry - The ZIP entry to extract.\n\t * @param zipfile - The open ZIP file instance.\n\t * @param outputDir - The directory where the entry should be written.\n\t * @returns A promise that resolves when the entry is fully written.\n\t */\n\tprivate async handleZipEntry(\n\t\tentry: yauzl.Entry,\n\t\tzipfile: yauzl.ZipFile,\n\t\toutputDir: string,\n\t): Promise<void> {\n\t\tconst fullPath = this.processZipEntryPath(outputDir, entry.fileName);\n\n\t\tif (entry.fileName.endsWith(\"/\")) {\n\t\t\t// it's a directory\n\t\t\tawait this.createDir(fullPath);\n\t\t\treturn;\n\t\t}\n\n\t\tawait this.createDir(path.dirname(fullPath));\n\n\t\treturn new Promise((response, reject) => {\n\t\t\tzipfile.openReadStream(entry, (readErr, readStream) => {\n\t\t\t\tif (readErr || !readStream) {\n\t\t\t\t\treturn reject(\n\t\t\t\t\t\tnew LokaliseError(`Failed to read ZIP entry: ${entry.fileName}`),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst writeStream = fs.createWriteStream(fullPath);\n\t\t\t\treadStream.pipe(writeStream);\n\t\t\t\twriteStream.on(\"finish\", response);\n\t\t\t\twriteStream.on(\"error\", reject);\n\t\t\t\treadStream.on(\"error\", reject);\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Creates a directory and all necessary parent directories.\n\t *\n\t * @param dir - The directory path to create.\n\t * @returns A promise that resolves when the directory is created.\n\t */\n\tprivate async createDir(dir: string): Promise<void> {\n\t\tawait fs.promises.mkdir(dir, { recursive: true });\n\t}\n\n\t/**\n\t * Resolves and validates the full output path for a ZIP entry.\n\t *\n\t * Prevents path traversal attacks by ensuring the resolved path stays within the output directory.\n\t *\n\t * @param outputDir - The base output directory.\n\t * @param entryFilename - The filename of the ZIP entry.\n\t * @returns The absolute and safe path to write the entry.\n\t * @throws {LokaliseError} If the entry path is detected as malicious.\n\t */\n\tprivate processZipEntryPath(\n\t\toutputDir: string,\n\t\tentryFilename: string,\n\t): string {\n\t\t// Validate paths to avoid path traversal issues\n\t\tconst fullPath = path.resolve(outputDir, entryFilename);\n\t\tconst relative = path.relative(outputDir, fullPath);\n\t\tif (relative.startsWith(\"..\") || path.isAbsolute(relative)) {\n\t\t\tthrow new LokaliseError(`Malicious ZIP entry detected: ${entryFilename}`);\n\t\t}\n\n\t\treturn fullPath;\n\t}\n\n\t/**\n\t * Parses and validates a URL string, ensuring it uses HTTP or HTTPS protocol.\n\t *\n\t * @param value - The URL string to validate.\n\t * @returns A parsed `URL` object if valid.\n\t * @throws {LokaliseError} If the URL is invalid or uses an unsupported protocol.\n\t */\n\tprivate assertHttpUrl(value: string): URL {\n\t\tlet parsed: URL;\n\t\ttry {\n\t\t\tparsed = new URL(value);\n\t\t} catch {\n\t\t\tthrow new LokaliseError(`Invalid URL: ${value}`);\n\t\t}\n\n\t\tif (parsed.protocol !== \"http:\" && parsed.protocol !== \"https:\") {\n\t\t\tthrow new LokaliseError(`Unsupported protocol in URL: ${value}`);\n\t\t}\n\n\t\treturn parsed;\n\t}\n}\n","import type { LokaliseError as ILokaliseError } from \"../interfaces/LokaliseError.js\";\n\n/**\n * Represents a custom error.\n */\nexport class LokaliseError extends Error implements ILokaliseError {\n\t/**\n\t * The error code representing the type of Lokalise API error.\n\t */\n\tcode?: number;\n\n\t/**\n\t * Additional details about the error.\n\t */\n\tdetails?: Record<string, string | number | boolean>;\n\n\t/**\n\t * Creates a new instance of LokaliseError.\n\t *\n\t * @param message - The error message.\n\t * @param code - The error code (optional).\n\t * @param details - Optional additional details about the error.\n\t */\n\tconstructor(\n\t\tmessage: string,\n\t\tcode?: number,\n\t\tdetails?: Record<string, string | number | boolean>,\n\t) {\n\t\tsuper(message);\n\t\tthis.code = code;\n\t\tthis.details = details;\n\t}\n\n\t/**\n\t * Returns a string representation of the error, including code and details.\n\t *\n\t * @returns The formatted error message.\n\t */\n\toverride toString(): string {\n\t\tlet baseMessage = `LokaliseError: ${this.message}`;\n\t\tif (this.code) {\n\t\t\tbaseMessage += ` (Code: ${this.code})`;\n\t\t}\n\t\tif (this.details) {\n\t\t\tconst formattedDetails = Object.entries(this.details)\n\t\t\t\t.map(([key, value]) => `${key}: ${value}`)\n\t\t\t\t.join(\", \");\n\n\t\t\tbaseMessage += ` | Details: ${formattedDetails}`;\n\t\t}\n\t\treturn baseMessage;\n\t}\n}\n","import {\n\tLokaliseApi,\n\tApiError as LokaliseApiError,\n\tLokaliseApiOAuth,\n} from \"@lokalise/node-api\";\nimport type { ClientParams, QueuedProcess } from \"@lokalise/node-api\";\nimport {\n\ttype LogFunction,\n\ttype LogLevel,\n\ttype LogThreshold,\n\tlogWithColor,\n\tlogWithLevel,\n} from \"kliedz\";\nimport { LokaliseError } from \"../errors/LokaliseError.js\";\nimport type {\n\tLokaliseExchangeConfig,\n\tRetryParams,\n} from \"../interfaces/index.js\";\n\n/**\n * A utility class for exchanging files with the Lokalise API.\n */\nexport class LokaliseFileExchange {\n\t/**\n\t * The Lokalise API client instance.\n\t */\n\tprotected readonly apiClient: LokaliseApi;\n\n\t/**\n\t * The ID of the project in Lokalise.\n\t */\n\tprotected readonly projectId: string;\n\n\t/**\n\t * Retry parameters for API requests.\n\t */\n\tprotected readonly retryParams: RetryParams;\n\n\t/**\n\t * Logger function.\n\t */\n\tprotected readonly logger: LogFunction;\n\n\t/**\n\t * Log threshold (do not print messages with severity less than the specified value).\n\t */\n\tprotected readonly logThreshold: LogThreshold;\n\n\t/**\n\t * Default retry parameters for API requests.\n\t */\n\tprivate static readonly defaultRetryParams: RetryParams = {\n\t\tmaxRetries: 3,\n\t\tinitialSleepTime: 1000,\n\t};\n\n\tprivate static readonly PENDING_STATUSES = [\n\t\t\"queued\",\n\t\t\"pre_processing\",\n\t\t\"running\",\n\t\t\"post_processing\",\n\t];\n\tprivate static readonly FINISHED_STATUSES = [\n\t\t\"finished\",\n\t\t\"cancelled\",\n\t\t\"failed\",\n\t];\n\n\tprivate static readonly RETRYABLE_CODES = [408, 429];\n\n\t/**\n\t * Creates a new instance of LokaliseFileExchange.\n\t *\n\t * @param clientConfig - Configuration for the Lokalise SDK.\n\t * @param exchangeConfig - The configuration object for file exchange operations.\n\t * @throws {LokaliseError} If the provided configuration is invalid.\n\t */\n\tconstructor(\n\t\tclientConfig: ClientParams,\n\t\t{\n\t\t\tprojectId,\n\t\t\tuseOAuth2 = false,\n\t\t\tretryParams,\n\t\t\tlogThreshold = \"info\",\n\t\t\tlogColor = true,\n\t\t}: LokaliseExchangeConfig,\n\t) {\n\t\tif (logColor) {\n\t\t\tthis.logger = logWithColor;\n\t\t} else {\n\t\t\tthis.logger = logWithLevel;\n\t\t}\n\n\t\tthis.logThreshold = logThreshold;\n\n\t\tlet lokaliseApiConfig = clientConfig;\n\n\t\tif (logThreshold === \"silent\") {\n\t\t\tlokaliseApiConfig = {\n\t\t\t\tsilent: true,\n\t\t\t\t...lokaliseApiConfig,\n\t\t\t};\n\t\t}\n\n\t\tif (useOAuth2) {\n\t\t\tthis.logMsg(\"debug\", \"Using OAuth 2 Lokalise API client\");\n\t\t\tthis.apiClient = new LokaliseApiOAuth(lokaliseApiConfig);\n\t\t} else {\n\t\t\tthis.logMsg(\"debug\", \"Using regular (token-based) Lokalise API client\");\n\t\t\tthis.apiClient = new LokaliseApi(lokaliseApiConfig);\n\t\t}\n\n\t\tthis.projectId = projectId;\n\n\t\tthis.retryParams = {\n\t\t\t...LokaliseFileExchange.defaultRetryParams,\n\t\t\t...retryParams,\n\t\t};\n\n\t\tthis.validateParams();\n\t}\n\n\t/**\n\t * Executes an asynchronous operation with exponential backoff retry logic.\n\t *\n\t * Retries the provided operation in the event of specific retryable errors (e.g., 429 Too Many Requests,\n\t * 408 Request Timeout) using an exponential backoff strategy with optional jitter. If the maximum number\n\t * of retries is exceeded, it throws an error. Non-retryable errors are immediately propagated.\n\t *\n\t * @template T The type of the value returned by the operation.\n\t * @param operation - The asynchronous operation to execute.\n\t * @returns A promise that resolves to the result of the operation if successful.\n\t * @throws {LokaliseError} If the maximum number of retries is reached or a non-retryable error occurs.\n\t */\n\tprotected async withExponentialBackoff<T>(\n\t\toperation: () => Promise<T>,\n\t): Promise<T> {\n\t\tconst { maxRetries, initialSleepTime } = this.retryParams;\n\t\tthis.logMsg(\n\t\t\t\"debug\",\n\t\t\t`Running operation with exponential backoff; max retries: ${maxRetries}`,\n\t\t);\n\n\t\tfor (let attempt = 1; attempt <= maxRetries + 1; attempt++) {\n\t\t\ttry {\n\t\t\t\tthis.logMsg(\"debug\", `Attempt #${attempt}...`);\n\n\t\t\t\treturn await operation();\n\t\t\t} catch (error: unknown) {\n\t\t\t\tif (error instanceof LokaliseApiError && this.isRetryable(error)) {\n\t\t\t\t\tthis.logMsg(\"debug\", `Retryable error caught: ${error.message}`);\n\n\t\t\t\t\tif (attempt === maxRetries + 1) {\n\t\t\t\t\t\tthrow new LokaliseError(\n\t\t\t\t\t\t\t`Maximum retries reached: ${error.message ?? \"Unknown error\"}`,\n\t\t\t\t\t\t\terror.code,\n\t\t\t\t\t\t\terror.details,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst backoff = initialSleepTime * 2 ** (attempt - 1);\n\t\t\t\t\tthis.logMsg(\"debug\", `Waiting ${backoff}ms before retry...`);\n\t\t\t\t\tawait LokaliseFileExchange.sleep(backoff);\n\t\t\t\t} else if (error instanceof LokaliseApiError) {\n\t\t\t\t\tthrow new LokaliseError(error.message, error.code, error.details);\n\t\t\t\t} else {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// This line is unreachable but keeps TS happy.\n\t\t/* istanbul ignore next */\n\t\tthrow new LokaliseError(\"Unexpected error during operation.\", 500);\n\t}\n\n\t/**\n\t * Polls the status of queued processes until they are marked as \"finished\" or until the maximum wait time is exceeded.\n\t *\n\t * @param {QueuedProcess[]} processes - The array of processes to poll.\n\t * @param {number} initialWaitTime - The initial wait time before polling in milliseconds.\n\t * @param {number} maxWaitTime - The maximum time to wait for processes in milliseconds.\n\t * @returns {Promise<QueuedProcess[]>} A promise resolving to the updated array of processes with their final statuses.\n\t */\n\tprotected async pollProcesses(\n\t\tprocesses: QueuedProcess[],\n\t\tinitialWaitTime: number,\n\t\tmaxWaitTime: number,\n\t): Promise<QueuedProcess[]> {\n\t\tthis.logMsg(\n\t\t\t\"debug\",\n\t\t\t`Start polling processes. Total processes count: ${processes.length}`,\n\t\t);\n\n\t\tconst startTime = Date.now();\n\t\tlet waitTime = initialWaitTime;\n\n\t\tconst processMap = new Map<string, QueuedProcess>();\n\n\t\t// Initialize processMap and set a default status if missing\n\t\tconst pendingProcessIds = new Set<string>();\n\n\t\tfor (const process of processes) {\n\t\t\tif (!process.status) {\n\t\t\t\tprocess.status = \"queued\"; // Assign default status if missing\n\t\t\t}\n\n\t\t\tprocessMap.set(process.process_id, process);\n\n\t\t\tif (LokaliseFileExchange.PENDING_STATUSES.includes(process.status)) {\n\t\t\t\tpendingProcessIds.add(process.process_id);\n\t\t\t}\n\t\t}\n\n\t\twhile (pendingProcessIds.size > 0 && Date.now() - startTime < maxWaitTime) {\n\t\t\tthis.logMsg(\"debug\", `Polling... Pending IDs: ${pendingProcessIds.size}`);\n\n\t\t\tawait Promise.all(\n\t\t\t\t[...pendingProcessIds].map(async (processId) => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst updatedProcess = await this.getUpdatedProcess(processId);\n\n\t\t\t\t\t\tprocessMap.set(processId, updatedProcess);\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tLokaliseFileExchange.FINISHED_STATUSES.includes(\n\t\t\t\t\t\t\t\tupdatedProcess.status,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tthis.logMsg(\"debug\", `Process ${processId} completed.`);\n\t\t\t\t\t\t\tpendingProcessIds.delete(processId);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tthis.logMsg(\"warn\", `Failed to fetch process ${processId}:`, error);\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\tif (\n\t\t\t\tpendingProcessIds.size === 0 ||\n\t\t\t\tDate.now() - startTime >= maxWaitTime\n\t\t\t) {\n\t\t\t\tthis.logMsg(\n\t\t\t\t\t\"debug\",\n\t\t\t\t\t`Finished polling. Pending processes IDs: ${pendingProcessIds.size}`,\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tthis.logMsg(\"debug\", `Waiting ${waitTime}...`);\n\t\t\tawait LokaliseFileExchange.sleep(waitTime);\n\t\t\twaitTime = Math.min(waitTime * 2, maxWaitTime - (Date.now() - startTime));\n\t\t}\n\n\t\treturn Array.from(processMap.values());\n\t}\n\n\t/**\n\t * Determines if a given error is eligible for retry.\n\t *\n\t * @param error - The error object returned from the Lokalise API.\n\t * @returns `true` if the error is retryable, otherwise `false`.\n\t */\n\tprivate isRetryable(error: LokaliseApiError): boolean {\n\t\treturn LokaliseFileExchange.RETRYABLE_CODES.includes(error.code);\n\t}\n\n\t/**\n\t * Logs a message with a specified level and the current threshold.\n\t *\n\t * @param level - Severity level of the message (e.g. \"info\", \"error\").\n\t * @param args - Values to log. Strings, objects, errors, etc.\n\t */\n\tprotected logMsg(level: LogLevel, ...args: unknown[]): void {\n\t\tthis.logger(\n\t\t\t{ level, threshold: this.logThreshold, withTimestamp: true },\n\t\t\t...args,\n\t\t);\n\t}\n\n\t/**\n\t * Retrieves the latest state of a queued process from the API.\n\t *\n\t * @param processId - The ID of the queued process to fetch.\n\t * @returns A promise that resolves to the updated queued process.\n\t */\n\tprivate async getUpdatedProcess(processId: string): Promise<QueuedProcess> {\n\t\tconst updatedProcess = await this.apiClient\n\t\t\t.queuedProcesses()\n\t\t\t.get(processId, { project_id: this.projectId });\n\n\t\tif (!updatedProcess.status) {\n\t\t\tupdatedProcess.status = \"queued\"; // Ensure missing status is defaulted\n\t\t}\n\n\t\treturn updatedProcess;\n\t}\n\n\t/**\n\t * Validates the required client configuration parameters.\n\t *\n\t * Checks for a valid `projectId` and ensures that retry parameters\n\t * such as `maxRetries` and `initialSleepTime` meet the required conditions.\n\t *\n\t * @throws {LokaliseError} If `projectId` or `retryParams` is invalid.\n\t */\n\tprivate validateParams(): void {\n\t\tif (!this.projectId || typeof this.projectId !== \"string\") {\n\t\t\tthrow new LokaliseError(\"Invalid or missing Project ID.\");\n\t\t}\n\n\t\tif (this.retryParams.maxRetries < 0) {\n\t\t\tthrow new LokaliseError(\n\t\t\t\t\"maxRetries must be greater than or equal to zero.\",\n\t\t\t);\n\t\t}\n\t\tif (this.retryParams.initialSleepTime <= 0) {\n\t\t\tthrow new LokaliseError(\"initialSleepTime must be a positive value.\");\n\t\t}\n\t}\n\n\t/**\n\t * Pauses execution for the specified number of milliseconds.\n\t *\n\t * @param ms - The time to sleep in milliseconds.\n\t * @returns A promise that resolves after the specified time.\n\t */\n\tprotected static sleep(ms: number): Promise<void> {\n\t\treturn new Promise((resolve) => setTimeout(resolve, ms));\n\t}\n}\n","import fs from \"node:fs\";\nimport path from \"node:path\";\nimport type { QueuedProcess, UploadFileParams } from \"@lokalise/node-api\";\nimport type {\n\tCollectFileParams,\n\tFileUploadError,\n\tPartialUploadFileParams,\n\tProcessUploadFileParams,\n\tProcessedFile,\n\tQueuedUploadProcessesWithErrors,\n\tUploadTranslationParams,\n} from \"../interfaces/index.js\";\nimport { LokaliseFileExchange } from \"./LokaliseFileExchange.js\";\n\n/**\n * Handles uploading translation files to Lokalise.\n */\nexport class LokaliseUpload extends LokaliseFileExchange {\n\tprivate static readonly maxConcurrentProcesses = 6;\n\n\tprivate static readonly defaultPollingParams = {\n\t\tpollStatuses: false,\n\t\tpollInitialWaitTime: 1000,\n\t\tpollMaximumWaitTime: 120_000,\n\t};\n\n\t/**\n\t * Collects files, uploads them to Lokalise, and optionally polls for process completion, returning both processes and errors.\n\t *\n\t * @param {UploadTranslationParams} uploadTranslationParams - Parameters for collecting and uploading files.\n\t * @returns {Promise<{ processes: QueuedProcess[]; errors: FileUploadError[] }>} A promise resolving with successful processes and upload errors.\n\t */\n\tasync uploadTranslations({\n\t\tuploadFileParams,\n\t\tcollectFileParams,\n\t\tprocessUploadFileParams,\n\t}: UploadTranslationParams = {}): Promise<QueuedUploadProcessesWithErrors> {\n\t\tthis.logMsg(\"debug\", \"Uploading translations to Lokalise...\");\n\n\t\tconst { pollStatuses, pollInitialWaitTime, pollMaximumWaitTime } = {\n\t\t\t...LokaliseUpload.defaultPollingParams,\n\t\t\t...processUploadFileParams,\n\t\t};\n\n\t\tthis.logMsg(\"debug\", \"Collecting files to upload...\");\n\t\tconst collectedFiles = await this.collectFiles(collectFileParams);\n\t\tthis.logMsg(\"debug\", \"Collected files:\", collectedFiles);\n\n\t\tthis.logMsg(\"debug\", \"Performing parallel upload...\");\n\t\tconst { processes, errors } = await this.parallelUpload(\n\t\t\tcollectedFiles,\n\t\t\tuploadFileParams,\n\t\t\tprocessUploadFileParams,\n\t\t);\n\n\t\tlet completedProcesses = processes;\n\t\tthis.logMsg(\n\t\t\t\"debug\",\n\t\t\t\"File uploading queued! IDs:\",\n\t\t\tcompletedProcesses.map((p) => p.process_id),\n\t\t);\n\n\t\tif (pollStatuses) {\n\t\t\tthis.logMsg(\"debug\", \"Polling queued processes...\");\n\n\t\t\tcompletedProcesses = await this.pollProcesses(\n\t\t\t\tprocesses,\n\t\t\t\tpollInitialWaitTime,\n\t\t\t\tpollMaximumWaitTime,\n\t\t\t);\n\n\t\t\tthis.logMsg(\"debug\", \"Polling completed!\");\n\t\t}\n\n\t\treturn { processes: completedProcesses, errors };\n\t}\n\n\t/**\n\t * Collects files from the filesystem based on the given parameters.\n\t *\n\t * @param {CollectFileParams} collectFileParams - Parameters for file collection, including directories, extensions, and patterns.\n\t * @returns {Promise<string[]>} A promise resolving with the list of collected file paths.\n\t */\n\tprotected async collectFiles({\n\t\tinputDirs = [\"./locales\"],\n\t\textensions = [\".*\"],\n\t\texcludePatterns = [],\n\t\trecursive = true,\n\t\tfileNamePattern = \".*\",\n\t}: CollectFileParams = {}): Promise<string[]> {\n\t\tconst queue = this.makeQueue(inputDirs);\n\t\tconst normalizedExtensions = this.normalizeExtensions(extensions);\n\t\tconst fileNameRegex = this.makeFilenameRegexp(fileNamePattern);\n\t\tconst excludeRegexes = this.makeExcludeRegExes(excludePatterns);\n\n\t\tconst files = await this.processCollectionQueue(\n\t\t\tqueue,\n\t\t\tnormalizedExtensions,\n\t\t\tfileNameRegex,\n\t\t\texcludeRegexes,\n\t\t\trecursive,\n\t\t);\n\n\t\treturn files.sort();\n\t}\n\n\t/**\n\t * Uploads a single file to Lokalise.\n\t *\n\t * @param {UploadFileParams} uploadParams - Parameters for uploading the file.\n\t * @returns {Promise<QueuedProcess>} A promise resolving with the upload process details.\n\t */\n\tprotected async uploadSingleFile(\n\t\tuploadParams: UploadFileParams,\n\t): Promise<QueuedProcess> {\n\t\treturn this.withExponentialBackoff(() =>\n\t\t\tthis.apiClient.files().upload(this.projectId, uploadParams),\n\t\t);\n\t}\n\n\t/**\n\t * Processes a file to prepare it for upload, converting it to base64 and extracting its language code.\n\t *\n\t * @param {string} file - The absolute path to the file.\n\t * @param {string} projectRoot - The root directory of the project.\n\t * @param {ProcessUploadFileParams} [processParams] - Optional processing settings including inferers.\n\t * @returns {Promise<ProcessedFile>} A promise resolving with the processed file details, including base64 content, relative path, and language code.\n\t */\n\tprotected async processFile(\n\t\tfile: string,\n\t\tprojectRoot: string,\n\t\tprocessParams?: ProcessUploadFileParams,\n\t): Promise<ProcessedFile> {\n\t\tlet relativePath: string;\n\t\ttry {\n\t\t\trelativePath = processParams?.filenameInferer\n\t\t\t\t? await processParams.filenameInferer(file)\n\t\t\t\t: \"\";\n\t\t\tif (!relativePath.trim()) {\n\t\t\t\tthrow new Error(\"Invalid filename: empty or only whitespace\");\n\t\t\t}\n\t\t} catch {\n\t\t\tconst toPosixPath = (p: string) => p.split(path.sep).join(path.posix.sep);\n\t\t\trelativePath = path.posix.relative(\n\t\t\t\ttoPosixPath(projectRoot),\n\t\t\t\ttoPosixPath(file),\n\t\t\t);\n\t\t}\n\n\t\tlet languageCode: string;\n\t\ttry {\n\t\t\tlanguageCode = processParams?.languageInferer\n\t\t\t\t? await processParams.languageInferer(file)\n\t\t\t\t: \"\";\n\t\t\tif (!languageCode.trim()) {\n\t\t\t\tthrow new Error(\"Invalid language code: empty or only whitespace\");\n\t\t\t}\n\t\t} catch {\n\t\t\tconst baseName = path.basename(relativePath);\n\t\t\tlanguageCode = baseName.split(\".\").slice(-2, -1)[0] ?? \"unknown\";\n\t\t}\n\n\t\tconst fileContent = await fs.promises.readFile(file);\n\n\t\treturn {\n\t\t\tdata: fileContent.toString(\"base64\"),\n\t\t\tfilename: relativePath,\n\t\t\tlang_iso: languageCode,\n\t\t};\n\t}\n\n\t/**\n\t * Uploads files in parallel with a limit on the number of concurrent uploads.\n\t *\n\t * @param {string[]} files - List of file paths to upload.\n\t * @param {Partial<UploadFileParams>} baseUploadFileParams - Base parameters for uploads.\n\t * @param {ProcessUploadFileParams} [processParams] - Optional processing settings including inferers.\n\t * @returns {Promise<{ processes: QueuedProcess[]; errors: FileUploadError[] }>} A promise resolving with successful processes and upload errors.\n\t */\n\tprivate async parallelUpload(\n\t\tfiles: string[],\n\t\tbaseUploadFileParams: PartialUploadFileParams = {},\n\t\tprocessParams?: ProcessUploadFileParams,\n\t): Promise<QueuedUploadProcessesWithErrors> {\n\t\tconst projectRoot = process.cwd();\n\t\tconst queuedProcesses: QueuedProcess[] = [];\n\t\tconst errors: FileUploadError[] = [];\n\t\tconst fileQueue = [...files];\n\n\t\tconst pool = new Array(LokaliseUpload.maxConcurrentProcesses)\n\t\t\t.fill(null)\n\t\t\t.map(() =>\n\t\t\t\t(async () => {\n\t\t\t\t\twhile (fileQueue.length > 0) {\n\t\t\t\t\t\tconst file = fileQueue.shift();\n\t\t\t\t\t\tif (!file) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst processedFileParams = await this.processFile(\n\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\tprojectRoot,\n\t\t\t\t\t\t\t\tprocessParams,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst queuedProcess = await this.uploadSingleFile({\n\t\t\t\t\t\t\t\t...baseUploadFileParams,\n\t\t\t\t\t\t\t\t...processedFileParams,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tqueuedProcesses.push(queuedProcess);\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\terrors.push({ file, error });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})(),\n\t\t\t);\n\n\t\tawait Promise.all(pool);\n\t\treturn { processes: queuedProcesses, errors };\n\t}\n\n\t/**\n\t * Normalizes an array of file extensions by ensuring each starts with a dot and is lowercase.\n\t *\n\t * @param extensions - The list of file extensions to normalize.\n\t * @returns A new array with normalized file extensions.\n\t */\n\tprivate normalizeExtensions(extensions: string[]): string[] {\n\t\treturn extensions.map((ext) =>\n\t\t\t(ext.startsWith(\".\") ? ext : `.${ext}`).toLowerCase(),\n\t\t);\n\t}\n\n\t/**\n\t * Determines whether a file should be collected based on its extension and name pattern.\n\t *\n\t * @param entry - The directory entry to evaluate.\n\t * @param normalizedExtensions - List of allowed file extensions.\n\t * @param fileNameRegex - Regular expression to match valid filenames.\n\t * @returns `true` if the file matches both extension and name pattern, otherwise `false`.\n\t */\n\tprivate shouldCollectFile(\n\t\tentry: fs.Dirent,\n\t\tnormalizedExtensions: string[],\n\t\tfileNameRegex: RegExp,\n\t): boolean {\n\t\tconst fileExt = path.extname(entry.name).toLowerCase();\n\t\tconst matchesExtension =\n\t\t\tnormalizedExtensions.includes(\".*\") ||\n\t\t\tnormalizedExtensions.includes(fileExt);\n\t\tconst matchesFilenamePattern = fileNameRegex.test(entry.name);\n\n\t\treturn matchesExtension && matchesFilenamePattern;\n\t}\n\n\t/**\n\t * Creates a regular expression from a given pattern string or RegExp.\n\t *\n\t * @param fileNamePattern - The filename pattern to convert into a RegExp.\n\t * @returns A valid RegExp object.\n\t * @throws {Error} If the pattern string is invalid and cannot be compiled.\n\t */\n\tprivate makeFilenameRegexp(fileNamePattern: string | RegExp): RegExp {\n\t\ttry {\n\t\t\treturn new RegExp(fileNamePattern);\n\t\t} catch {\n\t\t\tthrow new Error(`Invalid fileNamePattern: ${fileNamePattern}`);\n\t\t}\n\t}\n\n\t/**\n\t * Converts an array of exclude patterns into an array of RegExp objects.\n\t *\n\t * @param excludePatterns - An array of strings or regular expressions to exclude.\n\t * @returns An array of compiled RegExp objects.\n\t * @throws {Error} If any pattern is invalid and cannot be compiled.\n\t */\n\tprivate makeExcludeRegExes(excludePatterns: string[] | RegExp[]): RegExp[] {\n\t\tif (excludePatterns.length === 0) {\n\t\t\treturn [];\n\t\t}\n\t\ttry {\n\t\t\treturn excludePatterns.map((pattern) => new RegExp(pattern));\n\t\t} catch (err) {\n\t\t\tthrow new Error(`Invalid excludePatterns: ${err}`);\n\t\t}\n\t}\n\n\t/**\n\t * Safely reads the contents of a directory, returning an empty array if access fails.\n\t *\n\t * Logs a warning if the directory cannot be read (e.g. due to permissions or non-existence).\n\t *\n\t * @param dir - The directory path to read.\n\t * @returns A promise that resolves to an array of directory entries, or an empty array on failure.\n\t */\n\tprivate async safeReadDir(dir: string): Promise<fs.Dirent[]> {\n\t\ttry {\n\t\t\treturn await fs.promises.readdir(dir, { withFileTypes: true });\n\t\t} catch {\n\t\t\tthis.logMsg(\"warn\", `Skipping inaccessible directory: ${dir}...`);\n\t\t\treturn [];\n\t\t}\n\t}\n\n\t/**\n\t * Checks if a file path matches any of the provided exclusion patterns.\n\t *\n\t * @param filePath - The path of the file to check.\n\t * @param excludeRegexes - An array of RegExp patterns to test against.\n\t * @returns `true` if the file path matches any exclude pattern, otherwise `false`.\n\t */\n\tprivate shouldExclude(filePath: string, excludeRegexes: RegExp[]): boolean {\n\t\treturn excludeRegexes.some((regex) => regex.test(filePath));\n\t}\n\n\t/**\n\t * Creates a queue of absolute paths from the provided input directories.\n\t *\n\t * @param inputDirs - An array of input directory paths (relative or absolute).\n\t * @returns An array of resolved absolute directory paths.\n\t */\n\tprivate makeQueue(inputDirs: string[]): string[] {\n\t\treturn [...inputDirs.map((dir) => path.resolve(dir))];\n\t}\n\n\t/**\n\t * Processes a queue of directories to collect files matching given criteria.\n\t *\n\t * Recursively reads directories (if enabled), filters files by extension,\n\t * filename pattern, and exclusion rules, and collects matching file paths.\n\t *\n\t * @param queue - The list of directories to process.\n\t * @param exts - Allowed file extensions (normalized).\n\t * @param nameRx - Regular expression to match valid filenames.\n\t * @param excludeRx - Array of exclusion patterns.\n\t * @param recursive - Whether to traverse subdirectories.\n\t * @returns A promise that resolves to an array of matched file paths.\n\t */\n\tprivate async processCollectionQueue(\n\t\tqueue: string[],\n\t\texts: string[],\n\t\tnameRx: RegExp,\n\t\texcludeRx: RegExp[],\n\t\trecursive: boolean,\n\t): Promise<string[]> {\n\t\tconst found: string[] = [];\n\n\t\twhile (queue.length) {\n\t\t\tconst dir = queue.shift();\n\t\t\tif (!dir) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst entries = await this.safeReadDir(dir);\n\t\t\tfor (const entry of entries) {\n\t\t\t\tconst fullPath = path.resolve(dir, entry.name);\n\t\t\t\tthis.handleEntry(entry, fullPath, queue, found, {\n\t\t\t\t\texts,\n\t\t\t\t\tnameRx,\n\t\t\t\t\texcludeRx,\n\t\t\t\t\trecursive,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn found;\n\t}\n\n\t/**\n\t * Handles a single directory entry during file collection.\n\t *\n\t * Applies exclusion rules, optionally queues directories for recursion,\n\t * and collects files that match the specified extension and filename pattern.\n\t *\n\t * @param entry - The directory entry to handle.\n\t * @param fullPath - The absolute path to the entry.\n\t * @param queue - The processing queue for directories.\n\t * @param found - The list to store matched file paths.\n\t * @param opts - Options including extensions, name pattern, exclusions, and recursion flag.\n\t */\n\tprivate handleEntry(\n\t\tentry: fs.Dirent,\n\t\tfullPath: string,\n\t\tqueue: string[],\n\t\tfound: string[],\n\t\topts: {\n\t\t\texts: string[];\n\t\t\tnameRx: RegExp;\n\t\t\texcludeRx: RegExp[];\n\t\t\trecursive: boolean;\n\t\t},\n\t): void {\n\t\tif (this.shouldExclude(fullPath, opts.excludeRx)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (entry.isDirectory()) {\n\t\t\tif (opts.recursive) {\n\t\t\t\tqueue.push(fullPath);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (\n\t\t\tentry.isFile() &&\n\t\t\tthis.shouldCollectFile(entry, opts.exts, opts.nameRx)\n\t\t) {\n\t\t\tfound.push(fullPath);\n\t\t}\n\t}\n}\n"],"mappings":"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","names":["process","fs","path","path","fs"]}
{"version":3,"sources":["../lib/services/LokaliseDownload.ts","../lib/errors/LokaliseError.ts","../lib/services/LokaliseFileExchange.ts","../lib/services/LokaliseUpload.ts"],"sourcesContent":["import fs from \"node:fs\";\nimport os from \"node:os\";\nimport path from \"node:path\";\nimport { pipeline } from \"node:stream\";\nimport { promisify } from \"node:util\";\nimport type { DownloadBundle, DownloadFileParams } from \"@lokalise/node-api\";\nimport yauzl from \"yauzl\";\nimport { LokaliseError } from \"../errors/LokaliseError.js\";\nimport type { DownloadTranslationParams } from \"../interfaces/index.js\";\nimport { LokaliseFileExchange } from \"./LokaliseFileExchange.js\";\n\n/**\n * Handles downloading and extracting translation files from Lokalise.\n */\nexport class LokaliseDownload extends LokaliseFileExchange {\n\tprivate readonly streamPipeline = promisify(pipeline);\n\n\t/**\n\t * Downloads translations from Lokalise, saving them to a ZIP file and then extracting them.\n\t *\n\t * @param {DownloadTranslationParams} downloadTranslationParams - Configuration for download, extraction, and retries.\n\t * @throws {LokaliseError} If any step fails (e.g., download or extraction fails).\n\t */\n\tasync downloadTranslations(\n\t\tdownloadTranslationParams: DownloadTranslationParams,\n\t): Promise<void> {\n\t\tconst { downloadFileParams, extractParams = {} } =\n\t\t\tdownloadTranslationParams;\n\t\tconst outputDir = extractParams.outputDir ?? \"./locales\";\n\n\t\tconst translationsBundle =\n\t\t\tawait this.getTranslationsBundle(downloadFileParams);\n\t\tconst zipFilePath = await this.downloadZip(translationsBundle.bundle_url);\n\n\t\ttry {\n\t\t\tawait this.unpackZip(zipFilePath, outputDir);\n\t\t} finally {\n\t\t\tawait fs.promises.unlink(zipFilePath); // Cleanup ZIP file\n\t\t}\n\t}\n\n\t/**\n\t * Unpacks a ZIP file into the specified directory.\n\t *\n\t * @param {string} zipFilePath - Path to the ZIP file.\n\t * @param {string} outputDir - Directory to extract the files into.\n\t * @throws {LokaliseError, Error} If extraction fails for any reason.\n\t */\n\tasync unpackZip(zipFilePath: string, outputDir: string): Promise<void> {\n\t\tconst createDir = async (dir: string): Promise<void> => {\n\t\t\tawait fs.promises.mkdir(dir, { recursive: true });\n\t\t};\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tyauzl.open(zipFilePath, { lazyEntries: true }, async (err, zipfile) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn reject(err);\n\t\t\t\t}\n\n\t\t\t\tif (!zipfile) {\n\t\t\t\t\treturn reject(new LokaliseError(\"Failed to open ZIP file\"));\n\t\t\t\t}\n\n\t\t\t\tzipfile.readEntry();\n\t\t\t\tzipfile.on(\"entry\", async (entry) => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst fullPath = path.join(outputDir, entry.fileName);\n\n\t\t\t\t\t\tif (/\\/$/.test(entry.fileName)) {\n\t\t\t\t\t\t\t// Directory\n\t\t\t\t\t\t\tawait createDir(fullPath);\n\t\t\t\t\t\t\tzipfile.readEntry();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// File\n\t\t\t\t\t\t\tawait createDir(path.dirname(fullPath));\n\t\t\t\t\t\t\tconst writeStream = fs.createWriteStream(fullPath);\n\t\t\t\t\t\t\tzipfile.openReadStream(entry, (readErr, readStream) => {\n\t\t\t\t\t\t\t\tif (readErr || !readStream) {\n\t\t\t\t\t\t\t\t\treturn reject(new LokaliseError(\"Failed to read ZIP entry.\"));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treadStream.pipe(writeStream);\n\t\t\t\t\t\t\t\twriteStream.on(\"finish\", () => zipfile.readEntry());\n\t\t\t\t\t\t\t\twriteStream.on(\"error\", reject);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\treturn reject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tzipfile.on(\"end\", () => resolve());\n\t\t\t\tzipfile.on(\"error\", reject);\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Downloads a ZIP file from the given URL.\n\t *\n\t * @param {string} url - The URL of the ZIP file.\n\t * @returns {Promise<string>} The file path of the downloaded ZIP file.\n\t * @throws {LokaliseError} If the download fails or the response body is empty.\n\t */\n\tasync downloadZip(url: string): Promise<string> {\n\t\tconst tempZipPath = path.join(\n\t\t\tos.tmpdir(),\n\t\t\t`lokalise-translations-${Date.now()}.zip`,\n\t\t);\n\n\t\tconst response = await fetch(url);\n\t\tif (!response.ok) {\n\t\t\tthrow new LokaliseError(\n\t\t\t\t`Failed to download ZIP file: ${response.statusText}`,\n\t\t\t);\n\t\t}\n\n\t\tconst body = response.body;\n\t\tif (!body) {\n\t\t\tthrow new LokaliseError(\n\t\t\t\t`Response body is null. Cannot download ZIP file from URL: ${url}`,\n\t\t\t);\n\t\t}\n\n\t\tawait this.streamPipeline(body, fs.createWriteStream(tempZipPath));\n\t\treturn tempZipPath;\n\t}\n\n\t/**\n\t * Retrieves a translation bundle from Lokalise with retries and exponential backoff.\n\t *\n\t * @param {DownloadFileParams} downloadFileParams - Parameters for Lokalise API file download.\n\t * @returns {Promise<DownloadBundle>} The downloaded bundle metadata.\n\t * @throws {LokaliseError} If retries are exhausted or an API error occurs.\n\t */\n\tasync getTranslationsBundle(\n\t\tdownloadFileParams: DownloadFileParams,\n\t): Promise<DownloadBundle> {\n\t\treturn this.withExponentialBackoff(() =>\n\t\t\tthis.apiClient.files().download(this.projectId, downloadFileParams),\n\t\t);\n\t}\n}\n","import type { LokaliseError as ILokaliseError } from \"../interfaces/LokaliseError.js\";\n\n/**\n * Represents a custom error.\n */\nexport class LokaliseError extends Error implements ILokaliseError {\n\t/**\n\t * The error code representing the type of Lokalise API error.\n\t */\n\tcode?: number;\n\n\t/**\n\t * Additional details about the error.\n\t */\n\tdetails?: Record<string, any>;\n\n\t/**\n\t * Creates a new instance of LokaliseError.\n\t *\n\t * @param message - The error message.\n\t * @param code - The error code (optional).\n\t * @param details - Optional additional details about the error.\n\t */\n\tconstructor(message: string, code?: number, details?: Record<string, any>) {\n\t\tsuper(message);\n\t\tthis.code = code;\n\t\tthis.details = details;\n\t}\n\n\t/**\n\t * Returns a string representation of the error, including code and details.\n\t *\n\t * @returns The formatted error message.\n\t */\n\ttoString(): string {\n\t\tlet baseMessage = `LokaliseError: ${this.message}`;\n\t\tif (this.code) {\n\t\t\tbaseMessage += ` (Code: ${this.code})`;\n\t\t}\n\t\tif (this.details) {\n\t\t\tconst formattedDetails = Object.entries(this.details)\n\t\t\t\t.map(([key, value]) => `${key}: ${value}`)\n\t\t\t\t.join(\", \");\n\n\t\t\tbaseMessage += ` | Details: ${formattedDetails}`;\n\t\t}\n\t\treturn baseMessage;\n\t}\n}\n","import { LokaliseApi } from \"@lokalise/node-api\";\nimport type { ClientParams } from \"@lokalise/node-api\";\nimport { ApiError as LokaliseApiError } from \"@lokalise/node-api\";\nimport { LokaliseError } from \"../errors/LokaliseError.js\";\nimport type { LokaliseExchangeConfig } from \"../interfaces/LokaliseExchangeConfig.js\";\nimport type { RetryParams } from \"../interfaces/index.js\";\n\n/**\n * A utility class for exchanging files with the Lokalise API.\n */\nexport class LokaliseFileExchange {\n\t/**\n\t * The Lokalise API client instance.\n\t */\n\tpublic readonly apiClient: LokaliseApi;\n\n\t/**\n\t * The ID of the project in Lokalise.\n\t */\n\tprotected readonly projectId: string;\n\n\t/**\n\t * Retry parameters for API requests.\n\t */\n\tprotected readonly retryParams: RetryParams;\n\n\t/**\n\t * Default retry parameters for API requests.\n\t */\n\tprivate static readonly defaultRetryParams: RetryParams = {\n\t\tmaxRetries: 3,\n\t\tinitialSleepTime: 1000,\n\t};\n\n\t/**\n\t * Creates a new instance of LokaliseFileExchange.\n\t *\n\t * @param {ClientParams} clientConfig - Configuration for the Lokalise SDK.\n\t * @param {LokaliseExchangeConfig} exchangeConfig - The configuration object for file exchange operations.\n\t * @throws {Error} If the provided configuration is invalid.\n\t */\n\tconstructor(\n\t\tclientConfig: ClientParams,\n\t\texchangeConfig: LokaliseExchangeConfig,\n\t) {\n\t\t// Validate the API key\n\t\tif (!clientConfig.apiKey || typeof clientConfig.apiKey !== \"string\") {\n\t\t\tthrow new Error(\"Invalid or missing API token.\");\n\t\t}\n\n\t\t// Validate the project ID\n\t\tif (\n\t\t\t!exchangeConfig.projectId ||\n\t\t\ttypeof exchangeConfig.projectId !== \"string\"\n\t\t) {\n\t\t\tthrow new Error(\"Invalid or missing Project ID.\");\n\t\t}\n\n\t\t// Validate and sanitize retryParams\n\t\tconst mergedRetryParams = {\n\t\t\t...LokaliseFileExchange.defaultRetryParams,\n\t\t\t...exchangeConfig.retryParams,\n\t\t};\n\t\tif (mergedRetryParams.maxRetries < 0) {\n\t\t\tthrow new Error(\"maxRetries must be greater than or equal to zero.\");\n\t\t}\n\n\t\tthis.apiClient = new LokaliseApi(clientConfig);\n\t\tthis.projectId = exchangeConfig.projectId;\n\t\tthis.retryParams = mergedRetryParams;\n\t}\n\n\t/**\n\t * Executes an asynchronous operation with exponential backoff retry logic.\n\t *\n\t * Retries the provided operation in the event of specific retryable errors (e.g., 429 Too Many Requests,\n\t * 408 Request Timeout) using an exponential backoff strategy. If the maximum number of retries is exceeded,\n\t * it throws an error. Non-retryable errors are immediately propagated.\n\t *\n\t * @template T The type of the value returned by the operation.\n\t * @param {() => Promise<T>} operation - The asynchronous operation to execute.\n\t * @returns {Promise<T>} A promise that resolves to the result of the operation if successful.\n\t * @throws {LokaliseError} If the maximum number of retries is reached or a non-retryable error occurs.\n\t */\n\tprotected async withExponentialBackoff<T>(\n\t\toperation: () => Promise<T>,\n\t): Promise<T> {\n\t\tconst { maxRetries, initialSleepTime } = this.retryParams;\n\n\t\tfor (let attempt = 1; attempt <= maxRetries + 1; attempt++) {\n\t\t\ttry {\n\t\t\t\treturn await operation();\n\t\t\t} catch (error: unknown) {\n\t\t\t\tif (\n\t\t\t\t\terror instanceof LokaliseApiError &&\n\t\t\t\t\t(error.code === 429 || error.code === 408)\n\t\t\t\t) {\n\t\t\t\t\tif (attempt === maxRetries + 1) {\n\t\t\t\t\t\tthrow new LokaliseError(\n\t\t\t\t\t\t\t`Maximum retries reached: ${error.message ?? \"Unknown error\"}`,\n\t\t\t\t\t\t\terror.code,\n\t\t\t\t\t\t\terror.details,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tawait this.sleep(initialSleepTime * 2 ** (attempt - 1));\n\t\t\t\t} else if (error instanceof LokaliseApiError) {\n\t\t\t\t\tthrow new LokaliseError(error.message, error.code, error.details);\n\t\t\t\t} else {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthrow new LokaliseError(\"Unexpected error during operation.\", 500);\n\t}\n\n\t/**\n\t * Pauses execution for the specified number of milliseconds.\n\t *\n\t * @param {number} ms - The time to sleep in milliseconds.\n\t * @returns {Promise<void>} A promise that resolves after the specified time.\n\t */\n\tprotected sleep(ms: number): Promise<void> {\n\t\treturn new Promise((resolve) => setTimeout(resolve, ms));\n\t}\n}\n","import fs from \"node:fs\";\nimport path from \"node:path\";\nimport type { QueuedProcess, UploadFileParams } from \"@lokalise/node-api\";\nimport type { CollectFileParams } from \"../interfaces/CollectFileParams.js\";\nimport type { FileUploadError } from \"../interfaces/FileUploadError.js\";\nimport type { ProcessUploadFileParams } from \"../interfaces/ProcessUploadFileParams.js\";\nimport type { ProcessedFile } from \"../interfaces/ProcessedFile.js\";\nimport type { UploadTranslationParams } from \"../interfaces/UploadTranslationParams.js\";\nimport { LokaliseFileExchange } from \"./LokaliseFileExchange.js\";\n\n/**\n * Handles uploading translation files to Lokalise.\n */\nexport class LokaliseUpload extends LokaliseFileExchange {\n\tprivate readonly maxConcurrentProcesses = 6;\n\n\t/**\n\t * Collects files and uploads them to Lokalise, returning both processes and errors.\n\t *\n\t * @param {UploadTranslationParams} uploadTranslationParams - Parameters for collecting and uploading files.\n\t * @returns {Promise<{ processes: QueuedProcess[]; errors: FileUploadError[] }>} A promise resolving with successful processes and upload errors.\n\t */\n\tasync uploadTranslations(\n\t\tuploadTranslationParams: UploadTranslationParams,\n\t): Promise<{\n\t\tprocesses: QueuedProcess[];\n\t\terrors: FileUploadError[];\n\t}> {\n\t\tconst { uploadFileParams, collectFileParams, processUploadFileParams } =\n\t\t\tuploadTranslationParams;\n\n\t\tconst collectedFiles = await this.collectFiles(collectFileParams);\n\t\treturn this.parallelUpload(\n\t\t\tcollectedFiles,\n\t\t\tuploadFileParams,\n\t\t\tprocessUploadFileParams,\n\t\t);\n\t}\n\n\t/**\n\t * Collects files from the filesystem based on the given parameters.\n\t *\n\t * @param {CollectFileParams} collectFileParams - Parameters for file collection, including directories, extensions, and patterns.\n\t * @returns {Promise<string[]>} A promise resolving with the list of collected file paths.\n\t */\n\tasync collectFiles({\n\t\tinputDirs = [\"./locales\"],\n\t\textensions = [\".*\"],\n\t\texcludePatterns = [\"node_modules\", \"dist\"],\n\t\trecursive = true,\n\t\tfileNamePattern = \".*\",\n\t}: CollectFileParams = {}): Promise<string[]> {\n\t\tconst collectedFiles: string[] = [];\n\n\t\tconst traverseDirectory = async (dir: string) => {\n\t\t\tlet entries: fs.Dirent[];\n\n\t\t\ttry {\n\t\t\t\tentries = await fs.promises.readdir(dir, { withFileTypes: true });\n\t\t\t} catch {\n\t\t\t\treturn; // Skip inaccessible directories\n\t\t\t}\n\n\t\t\tconst tasks = entries.map(async (entry) => {\n\t\t\t\tconst fullPath = path.resolve(dir, entry.name);\n\n\t\t\t\tif (excludePatterns.some((pattern) => fullPath.includes(pattern))) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (entry.isDirectory() && recursive) {\n\t\t\t\t\tawait traverseDirectory(fullPath);\n\t\t\t\t} else if (entry.isFile()) {\n\t\t\t\t\tconst fileExt = path.extname(entry.name);\n\t\t\t\t\tconst matchesExtension = extensions.some(\n\t\t\t\t\t\t(ext) => ext === \".*\" || ext === fileExt,\n\t\t\t\t\t);\n\t\t\t\t\tconst matchesPattern = new RegExp(fileNamePattern).test(entry.name);\n\n\t\t\t\t\tif (matchesExtension && matchesPattern) {\n\t\t\t\t\t\tcollectedFiles.push(fullPath);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tawait Promise.all(tasks); // Wait for all tasks to complete\n\t\t};\n\n\t\tconst startTasks = inputDirs.map(async (dir) => {\n\t\t\ttry {\n\t\t\t\tconst stats = await fs.promises.lstat(dir);\n\t\t\t\tif (stats.isDirectory()) {\n\t\t\t\t\tawait traverseDirectory(path.resolve(dir));\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\treturn; // Skip invalid directories\n\t\t\t}\n\t\t});\n\n\t\tawait Promise.all(startTasks); // Wait for root directories to be processed\n\t\treturn collectedFiles;\n\t}\n\n\t/**\n\t * Uploads files in parallel with a limit on the number of concurrent uploads.\n\t *\n\t * @param {string[]} files - List of file paths to upload.\n\t * @param {Partial<UploadFileParams>} baseUploadFileParams - Base parameters for uploads.\n\t * @param {ProcessUploadFileParams} processUploadFileParams - Parameters for processing files before upload.\n\t * @returns {Promise<{ processes: QueuedProcess[]; errors: FileUploadError[] }>} A promise resolving with successful processes and upload errors.\n\t */\n\tasync parallelUpload(\n\t\tfiles: string[],\n\t\tbaseUploadFileParams: Partial<UploadFileParams> = {},\n\t\tprocessUploadFileParams: ProcessUploadFileParams = {},\n\t): Promise<{\n\t\tprocesses: QueuedProcess[];\n\t\terrors: FileUploadError[];\n\t}> {\n\t\tconst projectRoot = process.cwd();\n\t\tconst queuedProcesses: QueuedProcess[] = [];\n\t\tconst errors: FileUploadError[] = [];\n\n\t\tconst pool = new Array(this.maxConcurrentProcesses).fill(null).map(() =>\n\t\t\t(async () => {\n\t\t\t\twhile (files.length > 0) {\n\t\t\t\t\tconst file = files.shift();\n\t\t\t\t\tif (!file) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst processedFileParams = await this.processFile(\n\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\tprojectRoot,\n\t\t\t\t\t\t\tprocessUploadFileParams.languageInferer,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst queuedProcess = await this.uploadSingleFile({\n\t\t\t\t\t\t\t...baseUploadFileParams,\n\t\t\t\t\t\t\t...processedFileParams,\n\t\t\t\t\t\t});\n\t\t\t\t\t\tqueuedProcesses.push(queuedProcess);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\terrors.push({ file, error });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})(),\n\t\t);\n\n\t\tawait Promise.all(pool);\n\t\treturn { processes: queuedProcesses, errors };\n\t}\n\n\t/**\n\t * Uploads a single file to Lokalise.\n\t *\n\t * @param {UploadFileParams} uploadParams - Parameters for uploading the file.\n\t * @returns {Promise<QueuedProcess>} A promise resolving with the upload process details.\n\t */\n\tasync uploadSingleFile(\n\t\tuploadParams: UploadFileParams,\n\t): Promise<QueuedProcess> {\n\t\treturn this.withExponentialBackoff(() =>\n\t\t\tthis.apiClient.files().upload(this.projectId, uploadParams),\n\t\t);\n\t}\n\n\t/**\n\t * Processes a file to prepare it for upload, converting it to base64 and extracting its language code.\n\t *\n\t * @param {string} file - The absolute path to the file.\n\t * @param {string} projectRoot - The root directory of the project.\n\t * @param {(filePath: string) => Promise<string> | string} [languageInferer] - Optional function to infer the language code from the file path. Can be asynchronous.\n\t * @returns {Promise<ProcessedFile>} A promise resolving with the processed file details, including base64 content, relative path, and language code.\n\t */\n\tasync processFile(\n\t\tfile: string,\n\t\tprojectRoot: string,\n\t\tlanguageInferer?: (filePath: string) => Promise<string> | string,\n\t): Promise<ProcessedFile> {\n\t\tconst fileContent = await fs.promises.readFile(file);\n\t\tconst base64Data = fileContent.toString(\"base64\");\n\n\t\tconst relativePath = path.posix.relative(\n\t\t\tprojectRoot.split(path.sep).join(path.posix.sep),\n\t\t\tfile.split(path.sep).join(path.posix.sep),\n\t\t);\n\n\t\tlet languageCode: string;\n\t\ttry {\n\t\t\tlanguageCode = languageInferer ? await languageInferer(file) : \"\";\n\t\t\tif (!languageCode.trim()) {\n\t\t\t\tthrow new Error(\"Invalid language code: empty or only whitespace\");\n\t\t\t}\n\t\t} catch {\n\t\t\tlanguageCode = path.parse(path.basename(relativePath)).name;\n\t\t}\n\n\t\treturn {\n\t\t\tdata: base64Data,\n\t\t\tfilename: relativePath,\n\t\t\tlang_iso: languageCode,\n\t\t};\n\t}\n}\n"],"mappings":"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","names":["fs","path","fs","path"]}